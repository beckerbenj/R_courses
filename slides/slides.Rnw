\documentclass{beamer}

\usepackage{multicol}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{shapes.geometric}
\usepackage{hyperref}

\usetheme{metropolis}



\title{Introduction to Programming with R}
\institute{Zurich R Courses}


\author[Dries Debeer \& Benjamin Becker]{Dries Debeer \& Benjamin Becker}
\date{31. September and 01. October 2021}



<<r setup, echo=FALSE, message=FALSE, results="hide">>=
suppressPackageStartupMessages({
  library(knitr)
})

options(tinytex.verbose = TRUE)

knit_theme$set("acid")
opts_chunk$set(results="markup")
opts_chunk$set(echo = TRUE)
opts_chunk$set(eval = TRUE)
opts_chunk$set(strip.white = TRUE)
opts_chunk$set(size = "footnotesize")
opts_chunk$set(comment = ">")
opts_chunk$set(fig.width=3.5, fig.height=3) 


# Farben
mLightBrown<-"#EB811B"
econBlue<-"#008BBC"
econRed<-"#C10534"
econBlueD<-"#3E647D"
econRedD<-"#90353B"
@


\begin{document}



\begin{frame}
\titlepage
\end{frame}
\addtocounter{framenumber}{-1}


\begin{frame}{Table of Content}
\fontsize{5pt}{4}
\setcounter{tocdepth}{2}
\begin{multicols}{3}
  \tableofcontents
\end{multicols}
\end{frame}


\section{Introduction}

\begin{frame}{Introduction}
\begin{columns}[t]
\begin{column}{.475\textwidth}
    \textbf{Who are we?} 
    
    \vspace{0.3cm}
    
    \textcolor{mLightBrown}{Dries Debeer} \\
    
    \vspace{0.2cm}
    
    Senior Researcher at itec (imec research group at KU Leuven)
\end{column}
\begin{column}{.475\textwidth}
    \textbf{} 
    
    \vspace{0.3cm}
    
    \textcolor{mLightBrown}{Benjamin Becker} \\
    
    \vspace{0.2cm}
    
    Researcher at IQB (Statistics Department)
    
\end{column}
\end{columns}

\vspace{0.2cm}

\begin{columns}[t]
\begin{column}{.475\textwidth}
\href{https://github.com/ddebeer/scDIFtest}{scDIFtest}, \href{https://github.com/ddebeer/permimp}{permimp}, \href{https://github.com/beckerbenj/eatATA}{eatATA}, \href{https://CRAN.R-project.org/package=mstDIF}{mstDIF}
  	
\end{column}
\begin{column}{.475\textwidth}
\href{https://github.com/beckerbenj/eatGADS}{eatGADS}, \href{https://github.com/beckerbenj/eatDB}{eatDB}, \href{https://github.com/beckerbenj/eatATA}{eatATA}, \href{https://github.com/beckerbenj/pisaRT}{pisaRT}

  \end{column}
\end{columns}

\vspace{0.3cm}

\begin{columns}[t]
\begin{column}{.475\textwidth}

\href{mailto:dries.debeer@kuleuven.be}{dries.debeer@kuleuven.be}
  	
\end{column}
  \begin{column}{.475\textwidth}

\href{b.becker@iqb.hu-berlin.de}{b.becker@iqb.hu-berlin.de}

  \end{column}
\end{columns}

\vspace{1.5em}
\end{frame}

\begin{frame}{Introduction}
\textbf{Who are you?}
\begin{enumerate}%\itemsep0em
	\item Occupation, employer?
	\item Previous knowledge and experience
	\begin{itemize}
	  \item with R?
	  \item with other statistical software?
	  \item with other programming languages?
	\end{itemize}
	\item Specific interest/motivation for this workshop?
\end{enumerate}
\end{frame}


\subsection{Motivation}

\begin{frame}{Motivation}
	\begin{enumerate}
			\item Increase efficiency!
			\begin{itemize}
			  \item Save time and nerves
			  \item Avoid errors and bugs
			  \item High transfer effect to all projects (with data analyses)
			\end{itemize}
			\item Successful collaborations (including with your future self!)
			\item Code as deliverable (i.e., part of research paper)
	\end{enumerate}
\end{frame}

\begin{frame}{Motivation}
	Two of your worst collaborators:
	\begin{enumerate}
			\item Past Self
			\begin{itemize}
			  \item The biggest mess in existence
			  \item did not document anything
			  \item uses a completely different style of writing code
			  \item does not reply to e-mails
			\end{itemize}
			\item Future Self
			\begin{itemize}
			  \item has the memory of a goldfish
			  \item will have zero understanding for your current brilliance
			\end{itemize}
	\end{enumerate}
\end{frame}

\begin{frame}{Motivation}
\begin{center}
\includegraphics[width=.6\textwidth]{reinhart_rogoff.PNG}
\end{center}
\end{frame}

\begin{frame}{Motivation}
\begin{center}
\includegraphics[width=.75\textwidth]{bad_code_media.JPG}
\end{center}
\end{frame}

\begin{frame}{Motivation}
\textbf{Concept of Technical Debt}
\begin{itemize}
  \item We write (messy) code for data cleaning/analyses
  \item We decide on data sets/models/graphs/tables/...
  \item We try to publish it, get a major revision
  \item We need to rerun some analyses
  \item Modifying/extending our code is more difficult than it should be
\end{itemize}
\textbf{Trade-off}
\begin{itemize}
  \item Being fast vs. writing (or refactoring) perfect code
\end{itemize}
\textbf{But also}
\begin{itemize}
  \item Write better R code
\end{itemize}

\end{frame}


\subsection{Goal}

\begin{frame}{Goal of this workshop}

\textbf{An introduction to R as a Programming language}
\begin{itemize}
  \item Better practical R skills
  \item Better understanding of R (and programming)
  \item Different framing: R as a programming language
\end{itemize}
\end{frame}

\subsection{Agenda}

\begin{frame}{Agenda}
\textbf{Day 1}
\begin{itemize}
  \item RStudio setup
  \item Basic elements \& data types of the R language
  \item Flow \& conditional programming
  \item Loops \& iteration
  \item Functions (part I)
\end{itemize}

\textbf{Day 2}
\begin{itemize}
  \item Functions (part II)
  \item Debugging
  \item Functions (part III)
  \item Good programming practices
\end{itemize}
\end{frame}


% ----------------------------------------------------------------------------------------------------------------------
\section{RStudio setup}
\label{sec:rstudio}

\begin{frame}{RStudio setup}
\begin{enumerate}
  \item Copy the course content from the usb-stick to a directory on your machine
  \item Open RStudio
  \item Choose \texttt{File < New Project ... }
  \item Choose \texttt{Existing Directory}
  \item Browse to the directory on your machine where you copied the course content and select the ``Intro-R-programming'' folder as the \texttt{Project working directory}
  \item Click \texttt{Open in new session}
  \item Click \texttt{Create Project}
\end{enumerate}
\end{frame}

\begin{frame}{RStudio setup - optional}
\begin{enumerate}
  \item Choose \texttt{Tools < Global options}
  \item Under \texttt{General}
  \begin{itemize}
    \item DON'T \texttt{Restore .RData into workspace at startup}
    \item NEVER \texttt{Save workspace to .Rdata on exit:}
  \end{itemize}
  \item Further personalize RStudio
\end{enumerate}
\end{frame}


% ----------------------------------------------------------------------------------------------------------------------
\section{Basic elements \& data types}
\label{sec:basic}

\begin{frame}[fragile]
\begin{exampleblock}{}
  {\large \begin{quote}
``To understand computations in R, two slogans are helpful: Everything that exists is an object. {Everything} that happens is a function call.''
\end{quote}}
  \vskip5mm
  \hspace*\fill{\small--- John Chambers}
\end{exampleblock}
\end{frame}

\begin{frame}{Basic elements \& data types}
	\begin{itemize}
			\item What are objects?
			\item Atomic vectors
			\item Vector structures
			\item Subsetting
			\item Replacement
	\end{itemize}
\end{frame}

\subsection{What are objects?}

\begin{frame}{What are objects?}
	\begin{itemize}
			\item Data-structures that can be used in computations
			\item Collections of data of all kinds that are dynamically created and manipulated
			\item Can be very small, or very big. $\rightarrow$ \emph{Everything in R is an object}
			\item Elementary data structures can be combined in more complex data structures
			\item Creating new types of \emph{complex} objects is part of programming in R (S3, S4)
	\end{itemize}
\end{frame}


\subsection{Atomic Vectors}


\begin{frame}{Atomic Vectors - Basic Building Blocks}
\begin{center}
  \begin{tabular}{| l | l |}
    \hline
    \multicolumn{2}{|c|}{Basic object types} \\ \hline
    logical   & \texttt{TRUE}, \texttt{FALSE}, \texttt{NA} \\ 
    integer   & \texttt{1L}, \texttt{142}, \texttt{-5}, ..., \texttt{NA} \\
    double    & \texttt{1.0}, \texttt{1.25784}, \texttt{pi}, ..., \texttt{NA} \\
              & \texttt{NaN}, \texttt{-Inf}, \texttt{Inf} \\
    character & \texttt{"1"}, \texttt{"Some other string"}, ..., \texttt{NA} \\
    \hline
  \end{tabular}
\end{center}
mulitple values in one object $\rightarrow$ \texttt{length()} starting from \texttt{0}
\end{frame}

\begin{frame}[fragile]{Atomic Vectors - Basic Building Blocks}
Elements of the same type can be combined into an atomic vector using \texttt{c}.
<<combine, echo = TRUE, results = "markup">>=
c(3.3, 2.44, 9, 634)
@
All elements are of the same type!
\end{frame}

\begin{frame}[fragile]{Atomic Vectors - Basic Building Blocks}
An important object type with special behavior is \texttt{NULL}. \\
It is an empty object that can be interpreted as \emph{nothing}. It's length is 0.
<<NULL, echo = TRUE, results = "markup">>=
length(NULL)
@
\texttt{NULL} is mostly used as a default argument in functions, in order to create some default behavior.
\end{frame}


\subsubsection{Useful Functions}


\begin{frame}[fragile]{Useful Functions}
\texttt{?seq} Creates a vector with a sequence of numerical values.
<<seq, echo = TRUE, results = "markup", size = "footnotesize">>=
seq(0, 10, by = 2)
seq(0, 1, length.out = 11)
@
\end{frame}


\begin{frame}[fragile]{Useful Functions}
\texttt{seq\_along} and \texttt{seq\_len} are shortcuts.
<<seq_, echo = TRUE, results = "markup", size = "footnotesize">>=
seq_along(c("a", "b", "c", "d"))
seq_len(10)
@
Avoid \texttt{1:length(vector)} when programming!
\end{frame}

\begin{frame}[fragile]{Useful Functions}
\texttt{?rep} Creates a new vector by repeating the elements of a vector.
<<rep, echo = TRUE, results = "markup", size = "footnotesize">>=
rep(1:3, each = 2)
rep(1:3, times = 2)
@
\end{frame}

\begin{frame}[fragile]{Useful Functions}
\texttt{?rep} Creates a new vector by repeating the elements of a vector.
<<rep2, echo = TRUE, results = "markup", size = "footnotesize">>=
rep(c("a", "b", "c"), times = 2)
rep(c("this", "may", "be", "useful", "!"), 1:5)
@
\end{frame}


\begin{frame}[fragile]{Useful Functions}
\texttt{?paste} Creates a character vector by pasting multiple vectors together.
<<paste, echo = TRUE, results = "markup">>=
paste("one", "big", "string", sep = " ")
paste0("word_", seq(1, 4))
paste(c("ONE", "TWO"), seq(1, 3), 
      sep = " || ", collapse = "_-_")
@
\end{frame}


\begin{frame}[fragile]{Useful Functions}
\texttt{?unique} Creates a vector with the unique values of a vector.
<<unique, echo = TRUE, results = "markup">>=
unique(c("b", "a", "a", "b"))
@
\end{frame}


\begin{frame}[fragile]{Useful Functions}
\texttt{?sort} Creates a sorted version a Vector.
<<sort, echo = TRUE, results = "markup">>=
sort(c("b", "a", NA, "a", "b"))
sort(c("b", "a", NA, "a", "b"), na.last = TRUE)
sort(c(4, 2, 6, 1, 3, 5), decreasing = TRUE)
@
\end{frame}


\begin{frame}[plain]
\begin{center}
\Large Exercises \\

\vspace{1.5cm}
\includegraphics[height=.25\textheight]{exercises.jpg}
\end{center}
\end{frame}


\subsubsection{Coercion/Conversion}

\begin{frame}[fragile]{Coercion/Conversion}
\textbf{Automatic conversion}: \\
			NULL $\rightarrow$ logical $\rightarrow$ integer $\rightarrow$ double $\rightarrow$ character
<<auto-conversion, echo = TRUE, results = "markup">>=
1 + TRUE
@
\textbf{Explicit conversion}: \\
\texttt{as."type"()} \texttt{as.vector(, mode = "type")}
<<explicit conversion, echo = TRUE, results = "markup">>=
as.logical(0:5)
@
\end{frame}

\begin{frame}[fragile]{atomic vectors - check type}
Check type using: \texttt{is."type"()}
<<as.type, echo = TRUE, results = "markup">>=
is.null(NULL)
@
Check type using: \texttt{typeof()}
<<typeof, echo = TRUE, results = "markup">>=
typeof(TRUE + FALSE)
@
\end{frame}

\subsubsection{Assignment}

\begin{frame}[fragile]{Assignment}
In order to compute with objects efficiently, names can be assigned to the objects using the assignment operator \texttt{<-} (or \texttt{=})
<<assignment, echo = TRUE, results = "markup">>=
my_object <- TRUE
my_object
@
\begin{itemize}
  \item The objects (with references) that are available to a user can be seen in the global environment using \texttt{ls()}.
  \item R overrides previous assignments without a message.
Removed objects (\texttt{rm(objectName)}) cannot be restored. 
\end{itemize} 
$\rightarrow$ \textbf{\emph{May the source code be with you!}}
\end{frame}

\subsubsection{Attributes}

\begin{frame}[fragile]{Attributes}

Attributes can be attached to objects. An attribute: \\ 
\begin{itemize}
  \item has a name
  \item is itself also an object
  \item attributes are easily lost in computations. (One of the reasons to use OOP with classes and methods.)
\end{itemize}
<<attributes, echo = TRUE, results="markup", size="footnotesize">>=
my_object <- structure(5, 
                       my_attribute = "string", 
                       other_attribute = FALSE)
attributes(my_object)
@
\end{frame}

\begin{frame}[fragile]{Attributes}
There are several attributes with a specific use: \texttt{"names"}, \texttt{"dim"}, \texttt{"class"}, \texttt{"levels"}
\begin{itemize}
  \item \texttt{"names"} is a character vector that contains the names of elements of the vector/object. Names can be printed and set using \texttt{names(object) <- }.
  \item \texttt{"dim"} is an integer vector that specifies how we should interpret the vector (i.e., as a matrix, as an array). The dimensions of a vector can be printed and set using \texttt{dim(object) <- }.\\
  $\rightarrow$ a \texttt{matrix} or \texttt{array} is a vector with a \texttt{"dim"} attribute.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Attributes}
\begin{itemize}
  \item \texttt{"class"} is a character vector that contains class names. Classes can be printed and set using \texttt{class(object) <- }. \\
  See Object Oriented Programming (S3).
  \item \texttt{"levels"} is a character vector that contains the names levels of a factor. Levels can be printed and set using \texttt{levels(factor) <- }.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Attributes}
A factor in R is actually an integer vector with
\begin{itemize}
  \item a \texttt{"class"} attribute set to \texttt{"factor"}
  \item a \texttt{"levels"} attribute set to the level-labels that correspond to the integer values from 1 to the highest integer value in the integer vector.
\end{itemize}
\end{frame}

\begin{frame}{More Basic Object Types}
\begin{center}
  \begin{tabular}{| l | l |}
    \hline
    \multicolumn{2}{|c|}{More basic object types} \\ \hline
    complex     & \texttt{1 + 2.31i}, ... \texttt{NA} \\ 
    raw         & \texttt{as.raw(2)}, \texttt{charToRaw("a")} \\
    expression  & \texttt{expression(1+1, sum(a, b))} \\ 
    language    & a function call, \texttt{quote(1 + y)}  \\ \hline
    closure     & \texttt{function(x) x - 1}, \texttt{mean}  \\
    builtin     & \texttt{sum},  \texttt{c} \\
    special     & \texttt{for},  \texttt{return} \\ \hline
    environment & an environment \\
    symbol      & \texttt{quote(x)} \\ \hline
    ...         & ... \\
    \hline
  \end{tabular}
\end{center}
\end{frame}

\subsection{Vector Structures}

\begin{frame}[fragile]{Vector Structures}
\begin{center}
  \begin{tabular}{| l | l |}
    \hline
    \multicolumn{2}{|c|}{More basic object types} \\ \hline
    list        & \texttt{list()}, \texttt{as.list()}, ...  \\    \hline
    matrix      & a \textbf{vector} with \texttt{"dim"} argument: two dimensions \\
                & \texttt{matrix()}, \texttt{as.matrix()} \\ 
                & matrix algebra \\ 
    array       & a \textbf{vector} with with \texttt{"dim"} argument \\            \hline
    data.frame  & a \textbf{list} with vectors of equal length  \\
                & \texttt{data.frame()}, \texttt{as.data.frame()}  \\
    \hline
  \end{tabular}
\end{center}
\end{frame}

\subsubsection{List}

\begin{frame}[fragile]{List}
A list is a ``vector'' that can contain any type of elements
\begin{itemize}
  \item the types of elements can differ $\leftrightarrow$ atomic vectors
  \item possible elements including lists $\rightarrow$ recursive
  \item can have attributes
\end{itemize}
<<lists, echo = TRUE, results = "markup", size="footnotesize">>=
my_list <- list("this", 
                a = list(a = c(1:2)))
my_list
@
\end{frame}

\subsubsection{matrix \& Array}

\begin{frame}[fragile]{Matrix \& Array}
A matrix or an array is a vector with a \texttt{"dim"}-attribute
\begin{itemize}
  \item mostly useful for numeric vectors (integer and double)
  \item matrix algebra!  \texttt{t(matrix)}, \texttt{\%*\%}, \texttt{aperm(array)}, ...
  \item matrix has two dimensions, array has $n$ dimensions
You can create an matrix array using:
\end{itemize}
\begin{itemize}
  \item \texttt{cbind(vector1, vector2)}
  \item \texttt{rbind(vector1, vector2)}
  \item \texttt{matrix(vector, ncol = 4, nrow = 2)}
  \item \texttt{array(vector, dim = c())}
\end{itemize}
\end{frame}

\subsubsection{data.frame}

\begin{frame}[fragile]{Data.frame}
A data.frame is a list of (named) vectors of equal length.
\begin{itemize}
  \item has dimensions (but not a \texttt{"dim"}-attribute)
  \item the columns are the vectors
  \item the vectors can be lists (using \texttt{I()}).
  \item a data.frame has row names (but ignore these)
\end{itemize}
\end{frame}


\subsection{Subsetting - Selection}

\subsubsection{Subsetting - Atomic Vectors}

\begin{frame}[fragile]{Subsetting - Atomic vectors}
A subset of elements from a vector can be accessed using \texttt{object[selection]}, where \texttt{selection} is:
\begin{enumerate}
  \item a \textbf{logical} vector with the same length of the original vector (\texttt{TRUE}: select; \texttt{FALSE}: don't select)
  \item an \textbf{integer} vector indicating the indexes of the elements to select (or exclude)
  \item a \textbf{character} vector with the names of the elements to select
\end{enumerate}
\end{frame}

\begin{frame}{Subsetting - Atomic vectors}
Using a \textbf{logical} vector:
\begin{itemize}
  \item the logical vector should have the same length as the object. If shorter, the logical is repeated; if longer, \texttt{NA}s are added if \texttt{TRUE}. $\rightarrow$ always use the same length!
  \item handy when you want to select based on a condition related to the object values
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Subsetting - Atomic vectors}
Using a \textbf{logical} vector:
<<selection-logical, echo = TRUE, results = "markup">>=
my_object <- c(a = 1, b = 5, c = 3, d = 8)
my_object[my_object > 4]
@
\end{frame}

\begin{frame}{Subsetting - Atomic vectors}
Using an \textbf{integer} vector:
\begin{itemize}
  \item the integer vector can have any length (repeated indices are repeatedly selected)
  \item positive values mean \emph{select}, negative values mean \emph{drop}
  \item positive and negative values cannot be combined
  \item for integers higher than the number of elements in the vector, \texttt{NA}s are added
  \item using \texttt{which()} a logical vector is transformed in an integer vector with the indices of the elements that were \texttt{TRUE}
  \item double elements are truncated towards zero (using \texttt{as.integer()})
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Subsetting - Atomic vectors}
Using an \textbf{integer} vector:
<<selection-integer, echo = TRUE, results = "markup">>=
my_object <- c(a = 1, b = 5, c = 3, d = 8)
my_object[c(1, 2, 1, 2, 1, 2, 1 , 2, 1, 2, 1, 2)]
@
\end{frame}

\begin{frame}{Subsetting - Atomic vectors}
Using a \textbf{character} vector:
\begin{itemize}
  \item the strings that match with the names of the elements in the vector are returned
  \item the character vector can have any length (repeated names are repeatedly selected)
  \item only selection is possible (dropping is not)
  \item strings that are not matched with names return \texttt{NA}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Subsetting - Atomic vectors}
Using a \textbf{character} vector:
<<selection-character, echo = TRUE, results = "markup">>=
my_object <- c(a = 1, b = 5, c = 3, d = 8)
my_object[c("a", "c")]
@
\end{frame}

\begin{frame}[fragile]{Subsetting - Atomic vectors}
A \textbf{sinlge} element from a vector can be accessed using \texttt{object[[selection]]}, where \texttt{selection} is:
\begin{itemize}
  \item an \textbf{integer} value indicating the index of the element to select
  \item a \textbf{character} vector with the name of the element to select
\end{itemize}
<<selection-2, echo = TRUE, results = "markup">>=
my_object <- c(a = 1, b = 5, c = 3, c2 = 8)
my_object[[2]]
@
\end{frame}

\subsubsection{Subsetting - Matrix \& Arrays}

\begin{frame}[fragile]{Subsetting - Matrix \& Arrays}
Because arrays and matrices are atomic vectors (with a \texttt{"dim"} argument), the rules for atomic vectors apply.
\end{frame}

\begin{frame}[fragile]{Subsetting - Matrix \& Arrays}
In addition, selection is possible per dimension:
\begin{itemize}
  \item separated by a comma \texttt{[, ]}
  \item selection via character (match row or column names), integer (row and column number) or logical vectors
  \item the first vector selects the rows, the second the columns (and so on)
  \item \textbf{dimensions are dropped}, unless \texttt{drop = FALSE} 
\end{itemize}
<<selection-matrix 2, echo = TRUE, results = "markup", size="footnotesize">>=
my_matrix <- matrix(c(11, 21, 12, 22), ncol = 2, 
                    dimnames = list(paste0("row", 1:2), 
                                    paste0("col", 1:2)))
my_matrix[,2]
@
\end{frame}

\subsubsection{Subsetting - Matrix \& Arrays}

\begin{frame}[fragile]{Subsetting - Matrix \& Arrays}
Finally, the selection element can also be a matrix (with one column per dimension). Each row in the matrix selects one value.
<<selection-matrix 3, echo = TRUE, results = "markup", size="footnotesize">>=
my_matrix <- matrix(c(11, 12, 21, 22), ncol = 2, 
                    dimnames = list(paste0("row", 1:2), 
                                    paste0("col", 1:2)))
selection_matrix <- rbind(c(1, 1), c(1, 2), c(2, 1))
my_matrix[selection_matrix]
@
\end{frame}

\subsubsection{Subsetting - Vector Structures}

\begin{frame}[fragile]{Subsetting - Lists}
For lists, the rules are similar as for atomic vectors.
\begin{itemize}
  \item \texttt{list[selection]} gives a list (i.e., a subset of the original list)
  \item \texttt{list[[selection]]} gives the element (which can be a list)
  \item \texttt{list[["element\_name"]]} is the same as \texttt{list\$element\_name}
\end{itemize}
<<selection-list, echo = TRUE, results = "markup", size="footnotesize">>=
my_list<- list(a = 1, b = 5, c = 3, d = 8)
is.list(my_list["a"])
is.list(my_list[["a"]])
@
\end{frame}

\begin{frame}[fragile]{Subsetting - data.frames}
Because data.frames are lists, the rules for lists apply. 
<<selection-data.frame 1, echo = TRUE, results = "markup">>=
my_dat <- data.frame(col1 = c(11, 21), 
                     col2 = c(12, 22))
my_dat[1]
@
\end{frame}

\begin{frame}[fragile]{Subsetting - data.frames}
In addition, the selection rules for matrices can be used: 
\begin{itemize}
  \item selection per row and column (note the \texttt{drop} argument)
  \item selection via a matrix with two columns
\end{itemize}
<<selection-data.frame 2, echo = TRUE, results = "markup">>=
my_dat <- data.frame(col1 = c(11, 21), 
                     col2 = c(12, 22))
my_dat[,"col1", drop = FALSE]
@
\end{frame}


\begin{frame}[fragile]{Subsetting - data.frame \& matrix}
\metroset{block=fill} %grey blocks
\begin{block}{Programming advice}
  Code defensively: always use \texttt{, drop = FALSE} 
\end{block}
\end{frame}

\subsection{Element Replacement}

\begin{frame}[fragile]{Element Replacement}
A subset of elements from a vector or vector structure can be replaced using \texttt{object[selection] <- new\_values}:
\begin{itemize}
  \item the modifications are done in place
  \item the structure and class of the object stay unchanged
  \item the length of the new values should correspond with the length of the selection (the number of elements to replace should be a multiple of the number of new values)
  \item \emph{only for lists}: the replacement can be \texttt{NULL} (which removes the element from the list)
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Element Replacement}
<<replacement, echo = TRUE, results = "markup">>=
my_dat <- data.frame(col1 = c(11, 21), 
                     col2 = c(12, 22))
my_dat[1, 2] <- 33
my_dat
@
\end{frame}


\begin{frame}[plain]
\begin{center}
\Large Exercises \\

\vspace{1.5cm}
\includegraphics[height=.25\textheight]{exercises.jpg}
\end{center}
\end{frame}


% ----------------------------------------------------------------------------------------------------------------------
\section{Flow \& conditional programming}
\label{sec:flow}

\begin{frame}{Flow \& conditional programming}
R has specific tools (functions) that help organize the flow of computations. \\
You can make computations conditional on other objects (``conditional computation'') \\
The most commonly used tools are: 
\begin{itemize}
  \item \texttt{if} (+ \texttt{else})
  \item \texttt{ifelse}
\end{itemize}
\end{frame}

\subsection{if}

\begin{frame}[fragile]{Conditional Computation - if}
\texttt{if} statements have the basic form
<<if, echo=TRUE, eval = FALSE>>=
if(test){
  some_computations
}
@
\begin{itemize}
  \item \texttt{test} should be either \texttt{TRUE} or \texttt{FALSE} (or code that results in one of both). 
  \item If \texttt{test == TRUE}, than \texttt{some\_computations} is executed, if \texttt{test == FALSE}, than not.
  \item \textbf{Important}: \texttt{test} should have length 1. If not, only the first element is considered.\end{itemize}
\end{frame}

\begin{frame}[fragile]{Conditional Computation - if}
\texttt{else} can be added, but it is optional
<<if else, echo=TRUE, eval = FALSE>>=
if(test){
  some_computations
} else if (test_2){
  other_computations
} else {
  more_computations
}
@
\end{frame}

\begin{frame}{Typical test functions}
\begin{center}
  \begin{tabular}{| l | l |}
    \hline
    \multicolumn{2}{|c|}{Vectorized, elementwise} \\ \hline
    \texttt{==}                & equal to \\ 
    \texttt{!=}                & NOT equal to\\
    \texttt{>},  \texttt{>}    & is greater, less than \\
    \texttt{>=},  \texttt{>=}  & is greater, less than or equal to \\
    \texttt{\&}                 & AND operator \\
    \texttt{|}                 & OR operator \\
    \texttt{xor}               & exclusive OR \\
    \hline
  \end{tabular}
\end{center}
\end{frame}

\begin{frame}{Typical test functions}
\begin{center}
  \begin{tabular}{| l | l |}
    \hline
    \multicolumn{2}{|c|}{Not Vectorized} \\ \hline
    \texttt{identical()}       & identical to \\ 
    \texttt{any()}             & at least one \texttt{TRUE} \\
    \texttt{all()}             & all \texttt{TRUE} \\
    \texttt{\&\&}              & AND operator \\
    \texttt{||}                & OR operator \\
    \texttt{is.character()}, \texttt{is.data.frame()}, ...  &  \\
    \hline
  \end{tabular}
\end{center}
\end{frame}


\begin{frame}[fragile]{Typical test functions}
Compare:
<<test functions, echo = TRUE, results="markup">>=
c(TRUE, TRUE) & c(FALSE, TRUE)
c(TRUE, TRUE) && c(FALSE, FALSE)
@
\end{frame}

\begin{frame}[fragile]{Conditional Computation - if}
The \emph{test} should have length 1!
<<if3, results="markup", warning = TRUE>>=
# only the first element is evaluated
age <- c(8, 17, 39, 55)
if (age >= 18) {
  "can vote"
} else {
    "too young"
}
@
\end{frame}

\begin{frame}[fragile]{Conditional Computation - if}
Typical uses
<<if typical, echo=TRUE, eval = FALSE, size = "footnotesize">>=
if(any(is.na(x))){
  stop("computation impossible due to NA values")
}

if(!is.integer(vector)){
  warning("'vector' is automatically converted to interger.
          This may affect the results")
  vector <- as.integer(vector)
}

if(is.null(argument)){
  # default computations
} else if (argument == specific_value) {
  # other computations
}
@
\end{frame}

\begin{frame}{Conditional Computation - if}
\metroset{block=fill} %grey blocks
\begin{block}{Programming advice}
\begin{itemize}
  \item \emph{if} is almost always used inside of functions or loops
  \item If possible, avoid using \emph{else}
  \item Use meaningful initialization, early return(), stop(), etc. instead
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]{Conditional Computation - if}
Solution using \emph{if} and \emph{else} 
<<if else2, echo = TRUE, results="markup">>=
age <- 17
if (age >= 18) {
  vote <- "can vote"
} else {
  vote <- "too young"
}
vote
@
\end{frame}

\begin{frame}[fragile]{Conditional Computation - if}
Solution using meaningful initialization
<<if init, echo = TRUE, results="markup">>=
age <- 17
vote <- "too young"
if (age >= 18) {
  vote <- "can vote"
} 
vote
@
\end{frame}

\subsection{ifelse}

\begin{frame}[fragile]{Conditional Computation - ifelse}
A vectorized version is \texttt{ifelse()}. \\ 
<<ifelse, echo = TRUE, results="markup">>=
# all elements are evaluated
age <- c(8, 17, 39, 55)
ifelse(age >= 18, 
       yes = "can vote", 
       no = "too young")
@
%\texttt{\textasciigrave if\textasciigrave (test, ifTRUE, ifFALSE)} does exactly the same as \texttt{if (test) {ifTRUE} else {ifFALSE}}
\end{frame}

\begin{frame}[fragile]{Conditional Computation - ifelse}
Go-to tool for conditional recoding
<<ifelse typical, echo=TRUE, results = "markup">>=
age_estimated <- c(10, 20, 35, 60) 
age_self_rep <- c(NA, 17, 39, NA)

# Use available information, prioritize self report
ifelse(!is.na(age_self_rep), 
       yes = age_self_rep, 
       no = age_estimated)

@
\end{frame}

\begin{frame}[plain]
\begin{center}
\Large Exercises \\

\vspace{1.5cm}
\includegraphics[height=.25\textheight]{exercises.jpg}
\end{center}
\end{frame}

% ----------------------------------------------------------------------------------------------------------------------
\section{Loops \& Iteration}
\label{sec:loops}

\begin{frame}{Loops \& iteration}
R has specific tools (functions) that help organize the flow of computations. \\
You can repeat a similar computation multiple times typically with changing options (``iteration'').
The most commonly used tools are: 
\begin{itemize}
  \item loops (\texttt{repeat}, \texttt{while}, \texttt{for})
  \item functionals (\texttt{apply} - family)
\end{itemize}
\end{frame}


\subsection{for}

\begin{frame}[fragile]{Loops \& Iteration - for}
\texttt{for} statements have the basic form
<<for, echo=TRUE, eval = FALSE>>=
for (element in vector) {
  computation
}
@
For each element in the vector, the computation is executed. \\
Often, the computation depends on the element in that iteration.
\end{frame}

\begin{frame}[fragile]{Loops \& Iteration - for}
<<for2, echo=TRUE, eval = TRUE, results = "markup">>=
# iterate over a numeric vector
for (index in 1:3){
  cat(" computation -")
}

# iterate over a character vector
for (name in c("Alice", "Bob", "Casey")){
  if(name == "Bob") cat(" This was Bob -")
  else cat(" Not Bob -")
}
@
\end{frame}

\begin{frame}[fragile]{Loops \& Iteration - for}
Nested loops (over the rows and columns of a matrix)
<<for3, echo=TRUE, eval = TRUE, results = "markup">>=
matrix <- matrix(NA, nrow = 2, ncol = 3)
for (rowNr in 1:2){
  for (colNr in 1:3){
    matrix[rowNr, colNr] <- rowNr * 10 + colNr
  }
}
matrix
@
\end{frame}

\subsection{while \& repeat}

\begin{frame}[fragile]{Loops \& Iteration - while}
\texttt{while} statements have the basic form
<<while, echo=TRUE, eval = FALSE>>=
while (condition){
  computation
}
@
As long as the condition is TRUE, the computation is executed. \\ Often, the computation depends on something that is related to the condition.
\end{frame}

\begin{frame}[fragile]{Loops \& Iteration - while}
Sample five random values from a normal distribution, the distance between the
minimum and maximum should be at least 4.
<<while2, echo=TRUE, eval = TRUE>>=
max_dif <- 0
while (max_dif <= 4){
  cat("|")
  values <- rnorm(5)
  max_dif <- max(values) - min(values)
}
max_dif
round(values, 3)
@
\end{frame}

\begin{frame}[fragile]{Loops \& Iteration - repeat}
\texttt{repeat} statements have the basic form
<<repeat, echo=TRUE, eval = FALSE>>=
repeat {
  computation
}
@
Without a \texttt{break} the computation is repeated infinite times
\end{frame}

\subsection{next \& break}

\begin{frame}[fragile]{Loops \& Iteration - next break}
\begin{itemize}
  \item \texttt{next} starts next iteration
  \item \texttt{break} ends iteration (of the innermost loop)
\end{itemize}
<<next, echo=TRUE, eval = TRUE, results="markup">>=
index <- 0
repeat {
  index <- index + 1
  if (index %in% c(3, 5)) next
  if (index > 6) break
  print(index)
}
@
\end{frame}

\subsection{Loops \& Iteration - good practice}

\begin{frame}[fragile]{Iteration - Good practice}
\metroset{block=fill} %grey blocks
\begin{block}{Programming advice}
Use \texttt{seq()}, \texttt{seq\_len()}, or \texttt{seq\_along()}.
\end{block}
<<seq2, echo=TRUE, eval = TRUE, results="markup", size="footnotesize">>=
x <- numeric()
for (index in 1:length(x)){
  print(index)
}

for (index in seq_along(x)){
  print(index)
}
@
\end{frame}

\begin{frame}[fragile]{Loops \& Iteration - Good practice}
\metroset{block=fill} %grey blocks
\begin{block}{Programming advice}
Don't grow, replace.
\end{block}
<<replace, echo=TRUE, eval = TRUE, results="markup">>=
x <- letters
result1 <- numeric()          # grow
result2 <- numeric(length(x)) # replace
for (index in seq_along(x)){
  result1 <- c(result1, paste(index, x[index]))  # grow
  result2[index] <- paste(index, x[index])       # replace
}
@
\end{frame}

\subsection{Functionals}

\begin{frame}{Loops \& Iteration - Functionals}
A functional is a function that takes another function as an argument. \\
Focus on the \texttt{apply}-family. These functions \emph{apply} a function repeatedly. \\
Can be seen as an abstraction of a for loop, with the following advantages
\begin{itemize}
  \item requires less code to write
  \item does not store intermediate results
  \item no need to replace / grow
\end{itemize}
\end{frame}

\begin{frame}{Functionals}
The most commonly used functionals are:
\begin{itemize}
  \item \texttt{lapply} vector / list $\rightarrow$ list
  \item \texttt{sapply} vector / list $\rightarrow$ vector (matrix)
  \item \texttt{apply} matrix / array / data.frame $\rightarrow$ vector (matrix)
  \item \texttt{tapply}, \texttt{by}, \texttt{aggregate}
  \item \texttt{mapply}, \texttt{Map}
  \item \texttt{rapply}, \texttt{eapply}, \texttt{vapply} 
\end{itemize}
All of which have an argument that should be a function.
\end{frame}

\subsubsection{lapply}

\begin{frame}[fragile]{lapply}
data.frames are lists with the columns as elements:
<<lapply, echo=TRUE, results="markup", size="footnotesize">>=
lapply(iris, FUN = class)
@
\end{frame}

\begin{frame}[fragile]{lapply}
\begin{itemize}
  \item any type of element can be used
  \item other arguments can be passed through
\end{itemize}
<<lapply2, echo=TRUE, results="markup", size="footnotesize">>=
means <- lapply(airquality, FUN = mean, na.rm = TRUE)
str(means)
@
\end{frame}

%\subsubsection{sapply}
%
%\begin{frame}[fragile]{sapply}
%\begin{itemize}
%  \item wrapper around lapply
%  \item if possible, the ouput is combined into a atomic vector or matrix
%\end{itemize}
%<<sapply, echo=TRUE, eval = TRUE, results="markup">>=
%sapply(airquality, FUN = sd)
%sapply(airquality, FUN = quantile, prob = c(.1, .9), 
%       na.rm = TRUE)
%@
%\end{frame}

\subsubsection{apply}

\begin{frame}[fragile]{apply}
\begin{itemize}
  \item for objects with dimension (matrix, array, data.frame)
  \item apply over (a) chosen dimension(s) 
\end{itemize}
<<apply, echo=TRUE, results="markup", size="footnotesize">>=
my_matrix <- matrix(1:6, nrow = 2)
apply(my_matrix, 1, max)    # apply per row
apply(my_matrix, 2, max)    # apply per column
@
\end{frame}

\begin{frame}[fragile]{apply}
<<apply2, echo=TRUE, results="markup", size="footnotesize">>=
my_array <- array(1, dim = c(2, 3, 4))
apply(my_array, c(1, 2), sum)  # per row and column
apply(my_array, 3, sum)        # per "third dimension"
@
\end{frame}

\begin{frame}[plain]
\begin{center}
\Large Exercises \\

\vspace{1.5cm}
\includegraphics[height=.25\textheight]{exercises.jpg}
\end{center}
\end{frame}

% ----------------------------------------------------------------------------------------------------------------------
\section{Functions I}
\label{sec:fun1}


\begin{frame}[fragile]
\begin{exampleblock}{}
  {\large \begin{quote}
``To understand computations in R, two slogans are helpful: Everything that exists is an object. {Everything} that happens is a function call.''
\end{quote}}
  \vskip5mm
  \hspace*\fill{\small--- John Chambers}
\end{exampleblock}
\end{frame}


\subsection{Function Calls}

\begin{frame}{Function Calls}
Computing in R happens through function calls. A function is applied to one or more objects, and returns an object after the computation. 

\begin{figure}
\begin{center}
\begin{tikzpicture}
\node[draw,ellipse] (s1) at (0,0) {function};
\node[draw,rectangle] (s2) at (-4,0) {object1, \ (object2, ...)};
\node[draw,rectangle] (s3) at (3,0) {new object};
\path
    (s2) edge[->, double distance=1pt, >=latex'] (s1)
    (s1) edge[->, double distance=1pt, >=latex'] (s3);
\end{tikzpicture}
\end{center}
\caption{A function call.}
\label{fig1}
\end{figure}

The typical use is: \\ 
  \texttt{function(object1, argument = object2)}
  
\end{frame}

\begin{frame}{Function Calls}
\begin{itemize}
  \item Computations that seem not to be done using function calls are actually also function calls. \ 
  Try \texttt{\textasciigrave <-\textasciigrave (a, 5)} or \texttt{\textasciigrave >\textasciigrave (5, 2)}
  \item most functions that seem not to return an object, return it invisibly. Check \texttt{(a <- 5)}.
\end{itemize}
\end{frame}

\begin{frame}{Building Blocks}
Functions are the building blocks of R code. Writing functions allows you to organize and optimize the computations that you want to do. \\
Functions should:
\begin{itemize}
  \item have a clear purpose
  \item be well documented
  \item be portable
\end{itemize}
\end{frame}

\begin{frame}{Stepping Stone}
\textbf{Central stepping stone for R users:} \\
Move from solely using functions written by others to writing your own functions. 
\end{frame}


\begin{frame}{Function definition}
\begin{itemize}
  \item Name
  \item Arguments/Formals (input)
  \item Body (what happens inside, R-code with the computations)
  \item Output 
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Function definition}
<<echo=TRUE, size = "footnotesize">>=
                            # Name
countNA <- function(x) {    # Arguments/Formals
  out <- sum(is.na(x))      # Body
  out                       # Output
}
@
\end{frame}

\subsection{Function Names}

\begin{frame}{Function Names}
Every function needs a (meaningful) name!
\begin{itemize}
  \item Usually \textbf{a verb} (what does the function do?)
  \item Avoid existing names 
  \item Better longer than unclear
  \item CamelCase vs snake\_case
\end{itemize}
\end{frame}

\begin{frame}{Function Names}
\textbf{Good}
\begin{itemize}
  \item computeAIC()
  \item removeNAs()
  \item drop\_NA\_rows()
  \item factor\_to\_dummies()
\end{itemize}
\textbf{Bad}
\begin{itemize}
  \item myFun()
  \item foo()
  \item statistics()
  \item data\_preparation()
\end{itemize}
\end{frame}

\subsection{Arguments}

\begin{frame}{Arguments}
Most functions take one or multiple inputs. \\
These are usually:
\begin{itemize}
  \item One or two data arguments
  \item Additional Options
\end{itemize}
\end{frame}

\begin{frame}{Arguments}
Examples for zero arguments
\begin{itemize}
  \item getwd()
  \item Sys.time()
\end{itemize}
\end{frame}

\begin{frame}{Arguments}
Examples for one argument
\begin{itemize}
  \item dim()
  \item names()
\end{itemize}
\end{frame}

\begin{frame}{Arguments}
Examples for multiple arguments
\begin{itemize}
  \item mean()
  \item median()
  \item lm()
\end{itemize}
\end{frame}

\begin{frame}{Arguments}
\metroset{block=fill} %grey blocks
\begin{block}{Programming advice}
Less arguments = better!
\end{block}
\end{frame}

\begin{frame}[fragile]{Arguments}
Often arguments have to by objects of a specific type.
<<echo=TRUE, eval = FALSE >>=
sum(c("a", "b", "c"))  # gives an error
@
The documentation typically gives (or should give) information about what 
objects the arguments should be. Check \texttt{?sum}
\end{frame}

\subsection{Output}

\begin{frame}[fragile]{Output}
Functions usually return a single object, namely the last evaluated object.
<<echo=TRUE>>=
get_log_xtox <- function(x) {
  x_x <- x^x
  out <- log(x_x)
  out
}
get_log_xtox(2)
@
\end{frame}




\begin{frame}[plain]
\begin{center}
\Large Exercises \\

\vspace{1.5cm}
\includegraphics[height=.25\textheight]{exercises.jpg}
\end{center}
\end{frame}



\section{Functions II}
\label{sec:fun2}

\subsection{Why write functions?}

\begin{frame}{Reasons}
\textbf{Why write functions? }
\begin{itemize}
  \item They make code ...
  \begin{itemize}
    \item shorter (less repetition)
    \item easier to read and understand
  \end{itemize}
  \item They help avoid copy-paste errors
  \item They make it easier to change your code
  \item They increase transferability to ...
  \begin{itemize}
    \item other use cases
    \item other projects
    \item other persons
  \end{itemize}
  \item They keep your work space clean
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Readability}
\textbf{Writing a function:}
<<eval=FALSE>>=
RMSE <- get_RMSE(predictions, observations)
@
\textbf{Not writing a function:}
<<eval=FALSE>>=
diff <- observations - predictions
sq_diff <- diff^2
m_sq_diff <- mean(dif)
RMSE <- sqrt(m_sq_diff)
@
\end{frame}

\begin{frame}[fragile]{Readability}
\textbf{Writing a function:}
<< results='markup'>>=
summary(mtcars$mpg)
@
\end{frame}

\begin{frame}[fragile]{Readability}
\textbf{Not writing a function:}
<< results='markup'>>=
round(c("Min." = min(mtcars$mpg),
  "1st Qu." = as.numeric(quantile(mtcars$mpg)[2]),
  "Median" = median(mtcars$mpg),
  "Mean" = mean(mtcars$mpg),
  "3rd Qu." = as.numeric(quantile(mtcars$mpg)[4]),
  "Max." = max(mtcars$mpg)), 2)
@
\end{frame}

\subsection{Single return object}

\begin{frame}{Single return object}
Pure functions return a single object.
\begin{itemize}
  \item (Standard) The last evaluated object 
  \item Object defined by return()
\end{itemize}

\begin{figure}
\begin{center}
\begin{tikzpicture}
\node[draw,ellipse] (s1) at (0,0) {function};
\node[draw,rectangle] (s2) at (-4,0) {object1, \ (object2, ...)};
\node[draw,rectangle] (s3) at (3,0) {new object};
\path
    (s2) edge[->, double distance=1pt, >=latex'] (s1)
    (s1) edge[->, double distance=1pt, >=latex'] (s3);
\end{tikzpicture}
\end{center}
\caption{A pure function.}
\label{pure_function}
\end{figure}
\end{frame}

\begin{frame}[fragile]{Single return object}
\texttt{return()} stops the computation, and returns the object.
<<echo=TRUE>>=
return_early <- function(x = 1) {
  x2 <- x*2
  return(x2)
  out <- x + x2    # not executed
  out
}
return_early(2)
@
\end{frame}


\begin{frame}[fragile]{Single return object}
Multiple return objects can be combined in a list!
<< eval = FALSE, size = "footnotesize">>=
                            # Name
do_this <- function(vector, other_vector) { # Arguments
  # many computations                       # Body
  return(list(output1 = this, 
              output2 = that))              # Output
}
@
\end{frame}

\begin{frame}[fragile]{Single Return Object}
The return object is a list with multiple objects.
<< eval = TRUE, size = "footnotesize">>=
get_info <- function(x){
  mean_x <- mean(x)
  median_x <- median(x)
  n_obs_x <- length(x)
  range_x <- range(x)
  return(list(mean = mean_x, median = median_x, 
              n_obs = n_obs_x, range = range_x))
}
str(get_info(airquality$Wind))
@
\end{frame}

\subsection{Side effects}

\begin{frame}[fragile]{Side Effects}
Functions can have \textbf{``side effects''}:
\begin{itemize}
  \item console output
  \item plots
  \item write/save on drive
  \item ...
\end{itemize}

\begin{figure}
\begin{center}
\begin{tikzpicture}
\node[draw,ellipse] (s1) at (0,0) {function};
\node[draw,rectangle] (s2) at (-4,0) {object1, \ (object2, ...)};
\node[draw,rectangle] (s3) at (3,0) {new object};
\node[draw,diamond, aspect = 2] (s4) at (3,-2) {side effect};
\path
    (s2) edge[->, double distance=1pt, >=latex'] (s1)
    (s1) edge[->, double distance=1pt, >=latex'] (s3)
    (s1) edge[->, double distance=1pt, >=latex'] (s4);
\end{tikzpicture}
\end{center}
\caption{A function with side effect.}
\label{with_side_effect}
\end{figure}
\end{frame}

\begin{frame}[fragile]{Side Effects}
Console output: \texttt{?cat} and \texttt{?print}
<< results='markup', message=TRUE, size = "footnotesize">>=
print_info <- function(x){
  info <- get_info(x)
  cat("There are ", info$n_obs, 
      " observed values. \nThe mean is ", 
      round(info$mean, 2), ". \nThe median is ", 
      round(info$median, 2), ". \n", sep = "")
}
print_info(airquality$Wind)
@
\end{frame}

\begin{frame}[fragile]{Side effects}
Graphics output: Standard plot, ggplot2, lattice
<< eval=FALSE, size = "scriptsize">>=
hist2 <- function(x, title){
  info <- get_info(x)
  mean_median <- as.numeric(info[c("mean", "median")])
  hist(x, col = "skyblue", freq = FALSE, 
       main = paste0(title, " (n = ", info$n_obs, ")"))
  abline(v = mean_median, lwd = 2, 
         col = c("darkred", "darkblue"))
  text(mean_median, y = c(.11, .09),
       labels = paste(c("Mean", "Median"), 
                      round(mean_median, 2), 
                      sep = " = "),
       col = c("darkred", "darkblue"), pos = 4)
}
hist2(airquality$Wind, "Wind")
@
\end{frame}

\begin{frame}[fragile]{Side effects}
Graphics output
<<echo=FALSE, results='markup', message=TRUE, fig.width=3.5, fig.height=3>>=
hist2 <- function(x, title){
  info <- get_info(x)
  mean_median <- as.numeric(info[c("mean", "median")])
  hist(x, 
       main = paste0(title, " (n = ", info$n_obs, ")"),
       col = "skyblue", 
       freq = FALSE)
  abline(v = mean_median, 
         col = c("darkred", "darkblue"), 
         lwd = 2)
  text(mean_median, 
       y = c(.11, .09),
       labels = paste(c("Mean", "Median"), 
                      round(mean_median, 2), 
                      sep = " = "),
       col = c("darkred", "darkblue"),
       pos = 4)
}
hist2(airquality$Wind, "Wind")
@
\end{frame}



\begin{frame}{Output}
\metroset{block=fill} %grey blocks
\begin{block}{Programming advice}
\begin{itemize}
  \item Write pure functions (no-side effects)
  \item Write separate functions for side effects 
  \item Plotting functions should return \texttt{NULL} or the plot as an object
\end{itemize}
\end{block}

\begin{figure}
\begin{center}
\begin{tikzpicture}
\node[draw,ellipse] (s1) at (0,0) {function};
\node[draw,rectangle] (s2) at (-4,0) {object1, \ (object2, ...)};
\node[draw,rectangle] (s3) at (3,0) {NULL};
\node[draw,diamond, aspect = 2] (s4) at (3,-2) {side effect};
\path
    (s2) edge[->, double distance=1pt, >=latex'] (s1)
    (s1) edge[->, double distance=1pt, >=latex'] (s3)
    (s1) edge[->, double distance=1pt, >=latex'] (s4);
\end{tikzpicture}
\end{center}
\caption{A side effect function.}
\label{Pure_side_effect}
\end{figure}

\end{frame}

\subsection{Error, warning, \& message}

\begin{frame}[fragile]{Error, warning, \& message}
Error: computation is interrupted without return object! 

\vspace{0.3cm}


\texttt{?stop}
<<eval = TRUE>>=
get_log_xtox <- function(x) {
  if(!is.numeric(x)) stop("This does not work!")
  x_x <- x^x
  return(log(x_x))
}
get_log_xtox("a")
@
\end{frame}

\begin{frame}[fragile]{Error, warning, \& message}
Error: computation is interrupted without return object!
\begin{figure}
\begin{center}
\begin{tikzpicture}
\node[draw,ellipse] (s1) at (0,0) {function};
\node[draw,rectangle] (s2) at (-4,0) {object1, \ (object2, ...)};
\node[draw,star, star points=10] (s4) at (3,-2) {ERROR};
\path
    (s2) edge[->, double distance=1pt, >=latex'] (s1)
    (s1) edge[->, double distance=1pt, >=latex'] (s4);
\end{tikzpicture}
\end{center}
\caption{Computation with Error.}
\label{with_error}
\end{figure}
\end{frame}


\begin{frame}[fragile]{Error, warning, \& message}
\texttt{?stopifnot} is an abbreviation for \texttt{if(!test) stop()}:
<< error = TRUE>>=
get_log_xtox <- function(x) {
  stopifnot(is.numeric(x)) 
  x_x <- x^x
  return(log(x_x))
}
get_log_xtox("a")
@
\end{frame}

\begin{frame}[fragile]{Error, warning, \& message}
Message: To inform the user about something. 

\vspace{0.3cm}

\texttt{?message} 
<<results='markup'>>=
get_log_xtox <- function(x) {
  x_x <- x^x
  message("Thank you for using this function!")
  return(log(x_x))
}
get_log_xtox(2)
@

\end{frame}

\begin{frame}[fragile]{Error, warning, \& message}
Warning: Warn the user that something may be fishy. 

\vspace{0.3cm}

\texttt{?warning}
<<>>=
get_log_xtox <- function(x) {
  if(x < 0 && (x %% 2 == 0)) 
    warning("Not sure you can trust the result.", 
            call. = FALSE)
  x_x <- x^x
  return(log(x_x))
}
get_log_xtox(-2)
@

\end{frame}

\begin{frame}[fragile]{Error, warning, \& message}
Message \& warning: computation is NOT interrupted!
\begin{figure}
\begin{center}
\begin{tikzpicture}
\node[draw,ellipse] (s1) at (0,0) {function};
\node[draw,rectangle] (s2) at (-4,0) {object1, \ (object2, ...)};
\node[draw,rectangle] (s3) at (3,0) {new object};
\node[draw,star, star points=10] (s4) at (3,-2) {\textcolor{white}{T E S T}};
\node[] (s5) at (3,-1.7) {Message,};
\node[] (s6) at (3,-2.3) {Warning};
\path
    (s2) edge[->, double distance=1pt, >=latex'] (s1)
    (s1) edge[->, double distance=1pt, >=latex'] (s3)
    (s1) edge[->, double distance=1pt, >=latex'] (s4);
\end{tikzpicture}
\end{center}
\caption{A message or warning.}
\label{with_warning}
\end{figure}
\end{frame}




\begin{frame}{Output}
\metroset{block=fill} %grey blocks
\begin{block}{Programming advice}
\begin{itemize}
  \item Choose carefully when something warrants a message, warning or error
  \item Write clear and helpful warnings, errors, messages
\end{itemize}
\end{block}
\end{frame}



\subsection{Default Arguments}

\begin{frame}[fragile]{Default arguments}
What happens if the user omits an argument?
<<echo=TRUE, eval = TRUE>>=
add_ten <- function(x) {
  return(x + 10)
}
add_ten()
@
\end{frame}

\begin{frame}[fragile]{Default arguments}
Default arguments are made for such instances!
<<echo=TRUE, eval=TRUE>>=
add_ten_default <- function(x = 0) {
  return(x + 10)
}
add_ten_default()
@
\end{frame}

\begin{frame}[fragile]{Default arguments}
Additional arguments give (the user) flexibility. Default arguments keep the function easy to use. 

\vspace{0.3cm}

Try \texttt{?lm}
\metroset{block=fill} %grey blocks
\begin{block}{Programming advice}
\begin{itemize}
  \item Think which arguments to include, and which should (not) have defaults
  \item Choose sensible defaults
\end{itemize}
\end{block}
\end{frame}

\subsection{Lazy Evaluation}


\begin{frame}[fragile]{Lazy Evaluation}
\texttt{R} only considers (evaluates) an argument when it is used.
<<echo=TRUE>>=
add_ten_lazy <- function(x, y) {
  return(x + 10)
}
add_ten_lazy(2, y = stop("This is not evaluated"))
@
\end{frame}

\begin{frame}[fragile]{Lazy Evaluation}
\texttt{R} only considers (evaluates) an argument when it is used.
But, you can \texttt{force} the evaluation: 
<<echo=TRUE>>=
add_ten_force <- function(x, y) {
  force(y)
  return(x + 10)
}
add_ten_force(2, y = stop("Evaluation was forced"))
@
\texttt{?force}
\end{frame}


\begin{frame}[plain]
\begin{center}
\Large Exercises \\

\vspace{1.5cm}
\includegraphics[height=.25\textheight]{exercises.jpg}
\end{center}
\end{frame}

% ----------------------------------------------------------------------------------------------------------------------


% ----------------------------------------------------------------------------------------------------------------------
\section{Debugging}
\label{sec:debug}

\begin{frame}{Debugging}
\begin{itemize}
  \item browser()
  \item traceback()
  \item options(error = recover)
  \item options(warn = 2)
\end{itemize}
\end{frame}

\subsection{browser}

\begin{frame}[fragile]{browser()}
Inspecting a function interactively
<< eval=FALSE>>=
some_function <- function(x, y) {
  z <- x + y
  browser()
  z
}
some_function(x = 1, y = 5)
@
\end{frame}

\begin{frame}{browser()}
\begin{center}
\includegraphics[width=.75\textwidth]{browser.JPG}
\end{center}
\end{frame}

\begin{frame}{browser()}
Navigating within a browser:
\begin{itemize}
  \item [ls()] Show existing objects in the current environment
  \item [c] Exit the browser and continue execution
  \item [Q] Exit the browser, return to top level
  \item [where] Show call stack
\end{itemize}
\end{frame}

\subsection{traceback}

\begin{frame}{traceback()}
Understanding the call stack:
\begin{center}
\includegraphics[width=.75\textwidth]{traceback.JPG}
\end{center}
\end{frame}

\begin{frame}{traceback()}
Understanding the call stack:
\begin{center}
\includegraphics[height=.75\textheight]{traceback2.JPG}
\end{center}
\end{frame}

\subsection{recover}

\begin{frame}[fragile]{Recover}
Being able to chose an environment from the call stack:
<< eval=FALSE>>=
# on
options(error = recover)

# off
options(error = NULL)
@
\end{frame}

\begin{frame}{Recover}
Being able to chosse an enrivonment from a call stack:
\begin{center}
\includegraphics[width=.75\textwidth]{recover.JPG}
\end{center}
\end{frame}

\subsection{warnings}

\begin{frame}[fragile]{Warnings}
Turning warnings into errors
<< eval=FALSE>>=
# on
options(warn = 2)

# off
options(warn = 1)
@
\end{frame}

\begin{frame}[plain]
\begin{center}
\Large Exercises \\

\vspace{1.5cm}
\includegraphics[height=.25\textheight]{exercises.jpg}
\end{center}
\end{frame}



\section{Functions III}
\label{sec:fun3}


\subsection{Scoping rules}


\begin{frame}[fragile]{Where does a function find objects?}
R uses specific rules to find objects, which lead to the following: 
<< results='markup'>>=
a <- 55
add_a <- function(x){
  return(x + a)
}
add_a(5)
@
When a function is called, the computations in the body are run line by line. When \texttt{R} cannot find an object inside the function, it looks outside the function.
\end{frame}



\begin{frame}[fragile]{Where does a function find objects?}
\textbf{Name masking! }

\vspace{0.3cm}

Objects inside the function mask objects outside the function with the same name.

<< results='markup'>>=
a <- 55
add_a <- function(x){
  a <- 5
  return(x + a)
}
add_a(5)
@

\end{frame}


\begin{frame}[fragile]{Where does a function find objects?}
R uses specific rules to find objects.
<< results='markup'>>=
a <- b <- c <- d <- "fourth"
find_object <- function(a, b = "third", c = "third"){
  a <- "first"
  return(c(a = a, b = b, c = c, d = d))
}
find_object(b = "second")
@
\end{frame}



\begin{frame}[fragile]{Where does a function find objects?}
R uses specific rules to find objects.

\begin{enumerate}
  \item in the function body
  \item in the function call
  \item in the function definition
  \item outside the function
\end{enumerate}

Watch out with number 4! Frequently restart R: \texttt{Ctrl + shift + F4}
\end{frame}



\subsection{Functional Programming}



\begin{frame}[fragile]{Functional programming}
The return object should only depend on the arguments of the function, \emph{\textbf{not}} on the context! 

\vspace{0.3cm}

\textbf{BAD:}
<< results='markup'>>=
a <- 55
add_a <- function(x){
  return(x + a)
}
add_a(5)
@
\end{frame}



\begin{frame}[fragile]{Functional programming}
The return object should only depend on the arguments of the function, \emph{\textbf{not}} on the context!  

\vspace{0.3cm}

\textbf{GOOD:}
<< results='markup'>>=
add_a <- function(x, a = 55){
  return(x + a)
}
add_a(5)
@
\end{frame}



\begin{frame}[fragile]{Functional programming}
The function should not change the context.

\vspace{0.3cm}

\textbf{BAD}
<< results='markup'>>=
a <- 55
change_a <- function(new_a){
  a <<- new_a
  return(invisible(NULL))
}
change_a(5)
a
@
\end{frame}



\subsection{dot dot dot}

\begin{frame}{\texttt{...} dot-dot-dot }
R has a special argument (in the definition of the function):

\vspace{0.3cm}

\texttt{...} (dot-dot-dot)

\textbf{Examples:}
  \begin{itemize}
    \item \texttt{?sum}
    \item \texttt{?save}
    \item ...
  \end{itemize}
\end{frame}



\begin{frame}{\texttt{...} dot-dot-dot }

\texttt{...} can take \emph{any} number of additional arguments

Useful for passing arguments to other functions like:
  \begin{itemize}
    \item \texttt{?apply}
    \item \texttt{?plot}
    \item ...
  \end{itemize}
Useful when you don't know how many arguments there will be.
\end{frame}


\begin{frame}[fragile]{\texttt{...} dot-dot-dot}
\texttt{plot} example
<< results='markup', eval = FALSE>>=
hist3 <- function(x, ...){
  hist(x, ...)
  abline(v = mean(x, ...), 
         col = "darkred", 
         lwd = 2)
}
hist3(airquality$Wind, col = "pink", 
      main = "Wind (mph)")
@
\end{frame}

\begin{frame}[fragile]{\texttt{...} dot-dot-dot }
\texttt{plot} example
<< results='markup', echo = FALSE>>=
hist3 <- function(x, ...){
  hist(x, ...)
  abline(v = mean(x, ...), 
         col = "darkred", 
         lwd = 2)
}
hist3(airquality$Wind, col = "pink", 
      main = "Wind (mph)")
@
\end{frame}


\begin{frame}[fragile]{\texttt{...} dot-dot-dot }
\texttt{apply} example.
<< results='markup'>>=
get_quantiles <- function(x, ...){
  out <- lapply(x, quantile, ...)
  return(do.call(rbind, out))
}
get_quantiles(airquality, na.rm = TRUE, 
              probs = c(.25, .5, .27))
@
\end{frame}


\begin{frame}[fragile]{\texttt{...} dot-dot-dot}
\textbf{WARNING!} Watch out with spelling mistakes, arguments can get lost!
<< results='markup'>>=
get_quantiles <- function(x, ...){
  out <- lapply(x, quantile, ...)
  return(do.call(rbind, out))
}
get_quantiles(airquality, na.rm = TRUE, 
              prosb = c(.25, .5, .27))
@
\end{frame}

% \begin{frame}{dot-dot-dot \texttt{...}}
% 
% force names
% 
% \end{frame}


\subsection{on.exit()}

\begin{frame}[fragile]{on.exit()}
Performing an action when the function terminates.
<< results='markup'>>=
add_ten_on_exit <- function(x) {
  on.exit(cat("Finished 'add_ten_on_exit', with input '", 
              x, "'. \n", sep = ""))
  return(x + 10)
}
add_ten_on_exit(1)
@
\end{frame}


\begin{frame}[fragile]{on.exit()}
Performing an action when the function terminates.
<< results='markup'>>=
add_ten_on_exit <- function(x) {
  on.exit(cat("Finished 'add_ten_on_exit', with input '", 
              x, "'. \n", sep = ""))
  return(x + 10)
}
add_ten_on_exit("one")
@
\end{frame}


\begin{frame}[fragile]{Error, warning, \& message}

\begin{figure}
\begin{center}
\begin{tikzpicture}
\node[draw,ellipse] (s1) at (0,0) {function};
\node[draw,rectangle] (s2) at (-4,0) {object1, \ (object2, ...)};
\node[draw,star, star points=10] (s4) at (3,-2) {ERROR};
\node[draw,diamond, aspect = 2] (s5) at (3,2) {on.exit()};
\path
    (s2) edge[->, double distance=1pt, >=latex'] (s1)
    (s1) edge[->, double distance=1pt, >=latex'] (s4)
    (s1) edge[->, double distance=1pt, >=latex'] (s5);
\end{tikzpicture}
\end{center}
\caption{on.exit() with error.}
\label{on.exit}
\end{figure}
\end{frame}


\begin{frame}[fragile]{on.exit()}
Useful when your function has side effects:
<< results='markup', warning=FALSE, eval=FALSE>>=
hist3 <- function(x, ...){
  old_options <- getOption("warn")
  on.exit(options(warn = old_options))
  options(warn = -1)
  hist(x, ...)
  abline(v = mean(x, ...), 
         col = "darkred", lwd = 2)
}
hist3(airquality$Ozon, na.rm = TRUE)
@
\end{frame}


\begin{frame}[fragile]{on.exit()}
Useful when your function has side effects:
<< results='markup', warning=FALSE, echo=FALSE>>=
hist3 <- function(x, ...){
  old_options <- getOption("warn")
  on.exit(options(warn = old_options))
  options(warn = -1)
  hist(x, ...)
  abline(v = mean(x, ...), 
         col = "darkred", lwd = 2)
}
hist3(airquality$Ozon, na.rm = TRUE)
@
\end{frame}

<<echo=FALSE, results="hide">>=
warnings()
@


\subsection{Functions are objects}

\begin{frame}[fragile]
\begin{exampleblock}{}
  {\large \begin{quote}
``To understand computations in R, two slogans are helpful: Everything that exists is an object. {Everything} that happens is a function call.''
\end{quote}}
  \vskip5mm
  \hspace*\fill{\small--- John Chambers}
\end{exampleblock}
\end{frame}


\begin{frame}[fragile]{Functions are objects}
Functions are also objects. They can be arguments.
  \begin{itemize}
    \item \texttt{apply}-family
    \item ...
  \end{itemize}

<< results='markup'>>=
do_this_that <- function(function1, function2, x){
  function2(function1(x))
}
do_this_that(sum, log, 0:3)
@
\end{frame}

\begin{frame}[fragile]{Functions are objects}
Anonymous functions = functions without a name
<< results='markup'>>=
do_this_that(function(x) x^2, 
             function2 = function(y) sum(y) / (length(y - 1)), 
             -1:5)
@
\end{frame}


\begin{frame}[fragile]{Functions are objects}
The return objects can also be functions:
<< results='markup', eval=FALSE>>=
combine_2fun <- function(function_1, function_2){
  out_function <- function(x, ...) {
    function_2(function_1(x), ...)
  }
  return(out_function)
}

standardized_hist <- combine_2fun(scale, hist)
standardized_hist(airquality$Wind, 
                  col = "skyblue", 
                  main = "Standardized hist")
@
\end{frame}


\begin{frame}[fragile]{Functions are objects}
The return objects can also be functions:
<< results='markup', echo=FALSE>>=
combine_2fun <- function(function_1, function_2){
  out_function <- function(x, ...) {
    function_2(function_1(x), ...)
  }
  return(out_function)
}

standardized_hist <- combine_2fun(scale, hist)
standardized_hist(airquality$Wind, 
                  col = "skyblue", 
                  main = "Standardized hist")
@
\end{frame}


\begin{frame}[fragile]{Functions are objects}
The return objects can also be functions:
<< results='markup'>>=
combine_2fun <- function(function_1, function_2){
  out_function <- function(x, ...) {
    function_2(function_1(x), ...)
  }
  return(out_function)
}
mean_abs_deviation <- combine_2fun(abs, mean)
mean_abs_deviation(airquality$Ozone, na.rm = TRUE)
@
\end{frame}


\begin{frame}[fragile]{Functions are objects}
The return objects can also be functions:
<< results='markup'>>=
normalize <- combine_2fun(
  function(x) {x - min(x, na.rm = TRUE)},
  function(x) {x / max(x, na.rm = TRUE)})
normalize(airquality$Ozone)[1:4]
@
\end{frame}


\subsection{Work flow}

\begin{frame}{Writing Functions}
  Before creating the function
  \begin{itemize}
    \item What should my function do?
    \item Which input objects (Arguments)?
    \item which additional options (Arguments)?
    \item What should the output object be?
  \end{itemize}
  After creating the function
  \begin{itemize}
    \item Test it
    \item Add input validation
    \item Document
  \end{itemize}
\end{frame}


\subsection{Good functions?}

\begin{frame}{What makes a good function?}
\textbf{Pure functions!}
  \begin{itemize}
    \item no side effects
    \item no dependency on global environment
    \item only input via arguments (functional programming)
  \end{itemize}
  Results in easier understanding and higher portability.
\end{frame}

% \subsection{Accessing the function call}
% 
% \begin{frame}[fragile]{Accessing the function call}
% Accessing the function call
% << results='asis'>>=
% showArgs <- function(x, y) {
%   match.call()
% }
% showArgs(1, 2)
% @
% \end{frame}

\begin{frame}[plain]
\begin{center}
\Large Exercises \\

\vspace{1.5cm}
\includegraphics[height=.25\textheight]{exercises.jpg}
\end{center}
\end{frame}


% ----------------------------------------------------------------------------------------------------------------------
\section{Good programming practices}
\label{sec:good}

\subsection{Code Style}

\begin{frame}[fragile]
\begin{exampleblock}{}
  {\large ``Write code for humans, not for machines!''}
  \vskip5mm
  \hspace*\fill{\small}
\end{exampleblock}
\end{frame}

\begin{frame}{Code Style}
Invest time in writing readable R-code.
\begin{itemize}
  \item It will make collaborations easier
  \item It will make debugging easier
  \item It will help make your analyses reproducible 
\end{itemize}
There is a complete \emph{tidyverse} style-guide \url{https://style.tidyverse.org/}.
\end{frame}

\subsection{Go easy on your eyes}

\begin{frame}{Go easy on your eyes}
\begin{itemize}
  \item with spaces before and after: \texttt{-  +  /  *  =  <-  <  ==  > }
  \item always use \texttt{<-} for assignments
  \item only use \texttt{=} in function calls
  \item use indentation (largely automatic in RStudio)
  \item \texttt{CamelCaseNames} vs \texttt{snake\_case\_names}
  \item be consistent!
  \item wrap long lines at column 70-80 (Rstudio)
\end{itemize}
\end{frame}

\begin{frame}[fragile]{White space}
<<White space, eval = FALSE>>=
new_var=(var1*var2/2)-5/(var3+var4)

# versus

new_var <- (var1 * var2 / 2) - 5 / (var3 + var4)
@
\end{frame}

\begin{frame}[fragile]{Indentation}
<<Indentation, eval = FALSE, size="footnotesize">>=
for(name in names){formula=as.formula(paste0("y~.-",name))
fit<-lm(formula,data=my_data)
coefs[["name"]]=coef(fit)
print(name)
print(summary(fit))}

# versus

for(name in names){
  formula <- as.formula(paste0("y~.-", name))
  fit <- lm(formula, data = my_data)
  coefs[["name"]] <- coef(fit)
  print(name)
  print(summary(fit))
}
@
\end{frame}

\begin{frame}[fragile]{Wrap long lines}
<<Wrap long lines, eval = FALSE , size="footnotesize">>=
final_results <- data.frame(first_variable = 
sqrt(results$mean_squared_error), second_variable = 
paste0(results$condition, results$class, sep = ":"), 
third_variable = results$bias)

# versus

final_results <- data.frame(
  first_variable = sqrt(results$mean_squared_error), 
  second_variable = paste0(results$condition, 
                           results$class, sep = ":"),
  third_variable = results$bias)
@
\end{frame}

\subsection{Go easy on your mind}

\begin{frame}{Go easy on your mind}
\begin{itemize}
  \item use meaningful names: ``self-explainable''
  \item always write the formal arguments in function calls (except the first)
  \item benefit from autocompletion (\texttt{<tab>}) => embrace longer names
  \item use \texttt{TRUE} and \texttt{FALSE} not \texttt{T} and \texttt{F}
  \item comment, comment, comment
  \begin{itemize}
    \item NOT what (should be clear from the code)
    \item but why
    \item explain the reasoning, not the code 
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Use meaningful names}
<<Use meaningful names, eval = FALSE >>=
V <- myFun(m1_B)

# versus

RMSE_age_gender <- get_RMSE(lm_age_gender)
@
\metroset{block=fill} %grey blocks
\begin{block}{Programming advice}
Use \texttt{verbs} for functions and \texttt{nouns} for other objects.
\end{block}
\end{frame}

\begin{frame}[fragile]{Write formal arguments}
Benefit from auto completion using \texttt{tab}
<<Write formal arguments, eval = FALSE , size="footnotesize">>=
m1_B <- lm(outcome ~ age*gender, 
           exp1, condition_1, freq)

# versus

lm_age_gender <- lm(outcome ~ age * gender, 
                    data = exp1, 
                    subset = condition_1, 
                    weigths = freq)
@
\end{frame}

\begin{frame}[fragile]{Comment, comment, comment}
<<Comment, eval = FALSE , size="footnotesize">>=
## Start every Rscript with a comment that explains 
##  what the code in the script does, why it does 
##  this, and to which project it belongs. 
##  Your future self will be very thankful!
##
## Mention which packages you are using in this Rscript.

## Use sections to separate chunks ----------------------

## Maybe even subsections ===============================

## Recode variables so that missings are coded as "NA"
dat[dat %in% c(99, 999)] <- NA  # missings coded 99 or 999
@
\end{frame}


\subsection{R Peculiarities}


\begin{frame}[fragile]{Keep your code slim}
Try to limit your \emph{package-dependencies}.

\vspace{0.3cm}

Only load \texttt{library()} the packages that you absolutely need. If you are only using \texttt{dplyr}, it does not make sense to load the complete \texttt{tidyverse}.

\vspace{0.3cm}

\textbf{Controversial:} when possible, use the \texttt{::} operator (and consider not loading the package). \texttt{<package>::<function>} 
\begin{itemize}
  \item explicit dependencies
  \item less name conflicts
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Never Attach}
Forget about \texttt{attach()}! 

\vspace{0.3cm}

Don't use it, unless you completely understand what happens (see \texttt{?attach}).

\vspace{0.3cm}

Use \texttt{with(data.frame, expression)} instead.
<<attach, eval = FALSE >>=
# using with()
n <- 2e+4
data <- data.frame(x = runif(n), 
                   y = runif(n), 
                   z = seq_len(n))
result <- with(data, exp(x) / log(z) + 5 * sqrt(y))
@
\end{frame}


\begin{frame}{Testing R code}
Writing code is error prone. Incorporate tests and checks in your workflow. 
\begin{itemize}
  \item minimal examples
  \item write tests and checks
  \item helpful packages: \texttt{testthat}, \texttt{RUnit}, \texttt{testit}, ...
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Speed}
Computing speed can become an issue. Avoid common pitfalls:
\begin{itemize}
  \item don't grow, but replace
  \item vectorize where possible
  \item check the computing speed
\end{itemize}
\texttt{?system.time},  \text{microbenchmark} or profiling tools
<< >>=
n <- 2e+4
data <- data.frame(x = runif(n), 
                   y = runif(n), 
                   z = seq_len(n))
@
\end{frame}


\begin{frame}[fragile]{Speed}
Don't grow!
<< >>=
system.time({
  new_data <- NULL
  
  for(row_nr in seq_len(NROW(data))){
    new_data <- cbind(
      data[row_nr,], 
      result = exp(data$x[row_nr]) /
        log(data$z[row_nr]) + 
        5 * sqrt(data$y[row_nr]))
  }  
})
@
\end{frame}


\begin{frame}[fragile]{Speed}
Replace!
<< >>=
system.time({
  n_rows <- dim(data)[1]
  data$result <- rep(NA, n_rows)
  
  for(row_nr in seq_len(n_rows)){
    data$result[row_nr] <- exp(data$x[row_nr]) / 
      log(data$z[row_nr]) + 
      5 * sqrt(data$y[row_nr])
  } 
})
@
\end{frame}


\begin{frame}[fragile]{Speed}
Vectorize!
<< >>=
system.time({
  data$result <- exp(data$x) / log(data$z) + 
    5 * sqrt(data$y)
})
@
\end{frame}



\begin{frame}[fragile]{Speed}
Compare the speed of different implementations using: 

\vspace{0.3cm}

\texttt{microbenchmark::microbenchmark}
<< >>=
get_mean1 <- function(x){
  weight <- 1/length(x)
  out <- 0
  for(i in seq_along(x)){
    out <- out + x[i] * weight 
  }
  return(out)
}

get_mean2 <- function(x){
  sum(x)/length(x)
}
@
\end{frame}


\begin{frame}[fragile]{Speed}
Compare the speed of different implementations using: 

\vspace{0.3cm}

\texttt{microbenchmark::microbenchmark}
<< >>=
x <- rnorm(500)
microbenchmark::microbenchmark(
  mean(x), get_mean1(x), get_mean2(x))
@
\end{frame}


\begin{frame}[fragile]{Speed}

\metroset{block=fill} %grey blocks
\begin{block}{Programming advice}
Don't worry about speed before it becomes an issue.
\end{block}
\end{frame}



\subsection{Working with RStudio}

\begin{frame}{Working with RStudio}
``Every project should get an RStudio Project!'' 

\vspace{0.3cm}

Don't use \texttt{setwd(``path\/to\/my\/local\_folder'')} 

\vspace{0.3cm}

Issues when:
\begin{itemize}
  \item folders names are changed
  \item folders are moved
  \item a shared drive is used
  \item you ZIP and send the folder
\end{itemize}
\end{frame}

\begin{frame}{Working with RStudio}
Don't save work space to \texttt{.RData}.
\begin{itemize}
  \item Tools < Global Options < Workspace < Save workspace ....
  \item Save the code instead!
  \item Use \texttt{saveRDS()} and \texttt{readRDS()} for objects that require long computations
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Working with RStudio}
Don't use \texttt{rm(list = ls())} at the start of an Rscript.
\begin{itemize}
  \item Start clean, every time. 
  \item Keep it clean. No outside code, no outside computing.
  \item Regularly completely clean the work space (or restart the session).
\end{itemize}
<<restart,  eval = FALSE>>=
.rs.restartR()
@
\end{frame}

\begin{frame}{Working with RStudio}
Keep it clean
\begin{itemize}
  \item one folder per project!
  \item work on different projects in different RStudio instances!
  \item each with own R console, working directory, ...
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Working with RStudio}
Organize your project folder
\begin{itemize}
  \item R-folder with R scripts
  \item Data-folder with data
  \item split long scripts in meaningful chunks
  \item use relative paths (alternative: \href{https://CRAN.R-project.org/package=here}{here}-package)
\end{itemize}
<<organize,  eval = FALSE>>=
# read data
this_data <- read.csv("Data\the-correct-file.csv")

# source Rscript
source("R\01_first-script-to-source.R")
@
\end{frame}

\begin{frame}{Working with RStudio}
Use keyboard shortcuts
\begin{itemize}
  \item Can make working in RStudio more efficient
  \item Completely tunable: Tools < Modify Keyboard Shortcuts...
  \item Useful shortcuts (defaults):
  \begin{itemize}
    \item jump to editor: \texttt{ctrl + 1}
    \item jump to console: \texttt{ctrl + 2}
    \item jump to ...: \texttt{ctrl + 3-9}
    \item jump to next tab: \texttt{ctrl + tab}
    \item jump to previous tab: \texttt{ctrl + shift + tab}
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Working with RStudio}
More useful shortcuts (defaults):
\begin{itemize}
  \item run selection/selected line: \texttt{ctrl + enter}
  \item save current file: \texttt{ctrl + s}
  \item close current file: \texttt{ctrl + w} 
  \item restart R: \texttt{ctrl + shift + F10}
  \item Show help (for function at cursor) \texttt{F1}
  \item Show source code (for function at cursor) \texttt{F2}
\end{itemize}
More on this \href{https://support.rstudio.com/hc/en-us/articles/200711853-Keyboard-Shortcuts}{HERE}.
\end{frame}

\begin{frame}[plain]
\begin{center}
\Large Exercises \\

\vspace{1.5cm}
\includegraphics[height=.25\textheight]{exercises.jpg}
\end{center}
\end{frame}



% ----------------------------------------------------------------------------------------------------------------------
\section{Wrap Up}

\begin{frame}{General Advice}
\begin{itemize}
\item Investing time in learning R pays off
\item It's a steady learning curve
\item Learn from masters
\item Rewrite important code - the first attempt is usually not the best approach
\end{itemize}
\end{frame}

\begin{frame}{General R Advice}
\begin{itemize}
\item Document well
\item Use a consistent style
\item Write functions
\item Split long functions in smaller ones
\item Write wrappers
\item Use Iteration (don't copy paste)
\item Use matrix operations and vectorized functions instead of loops
\item Use git
\end{itemize}
\end{frame}

\begin{frame}{Literature Recommendations}
R Resources
\begin{itemize}
\item Avanced R Ed. 1 (\url{http://adv-r.had.co.nz/})
\item Avanced R Ed. 2 (\url{https://adv-r.hadley.nz/})
\item R Inferno (\url{https://www.burns-stat.com/pages/Tutor/R_inferno.pdf})
\item R Packages (\url{https://r-pkgs.org/})
\item Clean Code (\url{https://enos.itcollege.ee/~jpoial/oop/naited/Clean\%20Code.pdf})
\end{itemize}

\end{frame}


\begin{frame}[plain]

\begin{center}
\Large Thank you for your attention!

\visible<2>{Questions? Remarks?}
\end{center}

\end{frame}

\end{document}
