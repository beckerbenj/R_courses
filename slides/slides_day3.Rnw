\documentclass{beamer}

\usepackage{multicol}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{shapes.geometric}
\usepackage{hyperref}

\usetheme{metropolis}



\title{Advanced Programming in R}
\institute{Zurich R Courses}


\author[Dries Debeer \& Benjamin Becker]{Dries Debeer \& Benjamin Becker}
\date{15. October 2021}



<<r setup, echo=FALSE, message=FALSE, results="hide">>=
  suppressPackageStartupMessages({
    library(knitr)
  })

options(tinytex.verbose = TRUE)

knit_theme$set("acid")
opts_chunk$set(results="markup")
opts_chunk$set(echo = TRUE)
opts_chunk$set(eval = TRUE)
opts_chunk$set(strip.white = TRUE)
opts_chunk$set(size = "footnotesize")
opts_chunk$set(comment = ">")
opts_chunk$set(fig.width=3.5, fig.height=3) 


# Farben
mLightBrown<-"#EB811B"
econBlue<-"#008BBC"
econRed<-"#C10534"
econBlueD<-"#3E647D"
econRedD<-"#90353B"
@
  
  
  \begin{document}



\begin{frame}
\titlepage
\end{frame}

\addtocounter{framenumber}{-1}
\setcounter{tocdepth}{3}


\section{Introduction}

\begin{frame}{Introduction}
\begin{columns}[t]
\begin{column}{.475\textwidth}
\textbf{Who are we?} 

\vspace{0.3cm}

\textcolor{mLightBrown}{Dries Debeer} \\

\vspace{0.2cm}

Senior Researcher at itec (imec research group at KU Leuven)
\end{column}
\begin{column}{.475\textwidth}
\textbf{} 

\vspace{0.3cm}

\textcolor{mLightBrown}{Benjamin Becker} \\

\vspace{0.2cm}

Researcher at IQB (Statistics Department)

\end{column}
\end{columns}

\vspace{0.2cm}

\begin{columns}[t]
\begin{column}{.475\textwidth}
\href{https://github.com/ddebeer/scDIFtest}{scDIFtest}, \href{https://github.com/ddebeer/permimp}{permimp}, \href{https://github.com/beckerbenj/eatATA}{eatATA}, \href{https://CRAN.R-project.org/package=mstDIF}{mstDIF}

\end{column}
\begin{column}{.475\textwidth}
\href{https://github.com/beckerbenj/eatGADS}{eatGADS}, \href{https://github.com/beckerbenj/eatDB}{eatDB}, \href{https://github.com/beckerbenj/eatATA}{eatATA}, \href{https://github.com/beckerbenj/pisaRT}{pisaRT}

\end{column}
\end{columns}

\vspace{0.3cm}

\begin{columns}[t]
\begin{column}{.475\textwidth}

\href{mailto:dries.debeer@kuleuven.be}{dries.debeer@kuleuven.be}

\end{column}
\begin{column}{.475\textwidth}

\href{b.becker@iqb.hu-berlin.de}{b.becker@iqb.hu-berlin.de}

\end{column}
\end{columns}

\vspace{1.5em}
\end{frame}

\begin{frame}{Introduction}
\textbf{Who are you?}
\begin{enumerate}%\itemsep0em
\item Occupation, employer?
  \item Previous knowledge and experience
\begin{itemize}
\item with R?
  \item with other statistical software?
  \item with other programming languages?
  \end{itemize}
\item Specific interest/motivation for this workshop?
  \end{enumerate}
\end{frame}


\subsection{Goal}

\begin{frame}{What do we expect from you?}

\textbf{You ...}
\begin{itemize}
  \item are a frequent R user (e.g. for data wrangling/analyses/plots)
  \item have a rough understanding of R as a programming language\\
  $\rightarrow$ e.g. you have already written some R functions yourself
  \item are interested in learning more about the intricacies of R 
\end{itemize}
\end{frame}

\begin{frame}{Goal of this workshop}

\textbf{A deeper dive into R as a Programming language}
\begin{itemize}
  \item Better understanding of how R works as a programming language
  \item Better understanding of how larger programming projects can/should be structured
  \item Practical Git skills
  \item Practical R package building skills
\end{itemize}
\end{frame}

\subsection{Agenda}

\begin{frame}{Agenda}
\begin{itemize}
  \item Scoping \& Environments
  \item Functionals \& Split-Apply Paradigm
  \item Object Orientation (S3)
  \item Packages \& Version Controlling
\end{itemize}
\end{frame}



% -----------------------------------------------------------------------------------------------------------------


\section{Environments}

\subsection{Environments are bags}


\begin{frame}{Environments}
Understanding environments is key to understanding how R behaves, how R finds stuff.
\begin{itemize}
  \item Scoping
  \item Closures
  \item Namespaces
\end{itemize}
\end{frame}


\begin{frame}{Environments}
An environment = ``a bag of objects''. 

\vspace{0.3cm}

It differs from a list with respect to four key points:
\begin{enumerate}
  \item All elements have names
  \item The elements do not have an order
  \item Environments are not copied when modified
  \item Each environment has an \textbf{enclosing environment}
\end{enumerate}
\end{frame}



\begin{frame}{Environments}
Each environment consists of two parts: 
\begin{enumerate}
  \item a \textbf{frame}: a collection of named objects.
  \begin{itemize}
    \item the objects can be of any type (like in \texttt{lists})
    \item the objects have to be named (\textbf{unlike} in \texttt{lists})
  \end{itemize}
  \item an \textbf{enclosing enviroment}: a reference or link to another environment.
  \begin{itemize}
    \item the link goes in one direction
    \item determines the search path
  \end{itemize}
\end{enumerate}
\end{frame}

\subsection{Environments - frame}


\begin{frame}{Environments - frame}
The frame is a ``\textbf{bag}'' of named objects.
\begin{itemize}
  \item Actually, it is a bag of \emph{bindings} between names and objects
  \item The combination \emph{environment} + \emph{name} points to a specific 
  object (a location in memory) 
  \item The names in the bag have no order
\end{itemize}

\begin{center}
\includegraphics[height=.5\textheight]{from-Hadley/environment-bindings.png}
\end{center}
\end{frame}


\begin{frame}{Environments - frame}

An environment can containt itself!

\begin{center}
\includegraphics[height=.5\textheight]{from-Hadley/environment-self.png}
\end{center}
\end{frame}

\subsection{reference semantics}


\begin{frame}[fragile]{Environments - Reference Semantics}
How lists work:
<<>>=
original <- list(a = 15, b = "original", c = mean)
copy <- original
copy$b <- "new"
c(original$b, copy$b)
original$a <- NULL
names(original)
@
\end{frame}


\begin{frame}[fragile]{Environments - Reference Semantics}
How environments work:
<<>>=
original <- rlang::env(a = 15, b = "original", c = mean)
copy <- original
copy$b <- "new"
c(original$b, copy$b)
original$a <- NULL
names(original)
@
\end{frame}


\begin{frame}{Environments - enclosing environment}
\textbf{The link is used for lexical scoping:}

If the reference to an object is not found in the environment, R starts searching in the enclosing environment

\begin{center}
\includegraphics[height=.4\textheight]{from-Hadley/environment-link.png}
\end{center}

  \begin{itemize}
    \item the link goes in \textbf{one} direction
    \item an environment has only one enclosing environment
    \item an environment can enclose multiple environments (but it is hard to find out if so, and which)
    \item an environment can enclose itself (it is just a link!) $\rightarrow$ not very useful.
  \end{itemize}

\end{frame}


\begin{frame}[plain]
\begin{center}
\Large Exercises \\

\vspace{1.5cm}

\includegraphics[height=.25\textheight]{exercises.jpg}
\end{center}
\end{frame}


\subsection{scoping}


\begin{frame}{Environments - scoping}

\texttt{?exists} returns a logical if a reference is found in an environment. The search jumps to the enclosing environment until the object is found when \texttt{inherits = TRUE} (the default).

\texttt{?get} returns an object based on a name and an environment. The search jumps to the enclosing environment until the object is found when \texttt{inherits = TRUE} (the default).

\texttt{?assign} assigns an object to a name in an environment. 

If the reference to an object is not found in the environment, R starts searching in the enclosing environment

\end{frame}


\subsection{Important environments}

\begin{frame}{Environments}
Some important environments:
\begin{itemize}
  \item the global environment (\texttt{.GlobalEnv} or \texttt{globalenv()})
  \item the empty enviornment (\texttt{emptyenv()})
  \item the \texttt{package}-environment
  \item the \texttt{namespace}-environment
  \item the \texttt{imports}-environment
\end{itemize}

\end{frame}


\begin{frame}{Environments}
\textbf{The global enviroment}
\begin{itemize}
  \item the user's work space
  \item first item on the search path
  \item \texttt{.GlobalEnv} or \texttt{globalenv()}
\end{itemize}
\end{frame}


\begin{frame}{Environments}
\textbf{The empty enviroment}
\begin{itemize}
  \item An ``empty bag''
  \item last item on the search path
  \item has no enclosing environment
  \item \texttt{emptyenv()}
\end{itemize}

\end{frame}


\subsection{search path}


\begin{frame}[fragile]{Search path}
Where does R find objects \emph{during interactive use}?

\texttt{?search()}
<<>>=
search()
@

\texttt{package:<name>} environments have bindings to the exported objects (functions) of the package.
\end{frame}


\begin{frame}{Search path}
Where does R find objects \emph{during interactive use}?

\begin{center}
\includegraphics[width=\textheight]{from-Hadley/search-path.png}
\end{center}

Newly attached packages get a specific place in the search path. They become the enclosing environment of the global environment, and they are enclosed by the previously attached package. 
\end{frame}


\subsection{Environments and functions}


\begin{frame}{Environments and functions}
Four environments are related to functions:

\begin{enumerate}
  \item the environment that \textbf{binds} the function
  \item the environment in which the body of the function is \textbf{executed}
  \item the environment from which the function is \textbf{called}
  \item the \textbf{enclosing} environment
\end{enumerate}

\end{frame}


\begin{frame}[fragile]{Environments and functions}
\textbf{1. the environment that binds the function}

\texttt{?find} (can be misleading)

\texttt{?pryr::where}

<<>>=
add_10 <- function(x) x + 10
find("add_10")

find("sd")
@
\end{frame}

\begin{frame}[fragile]{Environments and functions}
\textbf{1. the environment that binds the function}
<<>>=
sd <- sd
find("add_10")

find("sd")
@
One name can be used in different environments (for different objects).

Functions (objects) can have references in more than one environment!
\end{frame}


\begin{frame}[fragile]{Environments and functions}
\textbf{2. the environment in which the body is executed}
\texttt{environment(NULL)}
<<>>=
get_executing_env <- function() environment()
get_executing_env()
get_executing_env()  # always new
@
The execution environment disappears when the body is executed. Unless it 
becomes the enclosing environment of another function.
\end{frame}


\begin{frame}[fragile]{Environments and functions}
\textbf{3. the environment from which the function is called}
\texttt{?parent.frame}
<<>>=
print_calling_env <- function() parent.frame()
print_calling_env()
other_fun <- function() print_calling_env()
other_fun()
@
\end{frame}


\begin{frame}[fragile]{Environments and functions}
\textbf{3. the environment from which the function is called}

This environment is often a execution environment of another function.
\begin{itemize}
  \item To get the calling function use \texttt{?sys.call}. 
  \item To get the complete call stack use \texttt{?sys.calls}. 
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Environments and functions}
\textbf{3. the environment from which the function is called}

\texttt{?sys.calls}
<< eval = FALSE>>=
print_calling_funs <- function() sys.calls()
print_calling_funs()
other_fun <- function() print_calling_funs()
other_fun()
@
\end{frame}



\begin{frame}[fragile]{Environments and functions}
\textbf{4. the enclosing environment}

\texttt{environment(function)}
<<>>=
get_enclosing_env <- function() parent.env(environment())
get_enclosing_env()
@
\end{frame}


\begin{frame}[fragile]{Environments and functions}
\textbf{4. the enclosing environment}
\texttt{environment(function)}
<<>>=
make_adder <- function(add = 0) {
  print(environment())
  return(function(x) x + add)}
add_5 <- make_adder(5)
environment(add_5)
@
The execution environment disappears when the body is executed. Unless it becomes the enclosing environment of another function
\end{frame}


\begin{frame}[fragile]{Environments and functions}
\textbf{4. the enclosing environment}

\vspace{0.3cm}

When a function is created, the binding environment and the enclosing environment
are typically equal. But the enclosing environment can be changed (using 
\texttt{environment <-})
<<>>=
strange_mean <- function(x, ...) mean(x, ...)
strange_mean(1:3)
env1 <- rlang::env(mean = function(x, ...) "Strange!")
environment(strange_mean) <- env1
strange_mean(1:3)
@
\end{frame}

\begin{frame}{Environments and functions}
Four environments are related to functions:

\begin{enumerate}
  \item the environment that \textbf{binds} the function
  \item the environment in which the body of the function is \textbf{executed}
  \item the environment from which the function is \textbf{called}
  \item the \textbf{enclosing} environment
\end{enumerate}

\end{frame}


\subsection{Where does R find stuff?}


\begin{frame}{Where does R find stuff?}
From \emph{inside functions}?
\begin{enumerate}
  \item the execution environment
  \item the enclosing environment
  \item the enclosing environment of that environment
  \item ...
  \item the empty environment
\end{enumerate}
\end{frame}


\begin{frame}{Where does R find stuff?}
From inside functions \emph{defined in the global environment}?
\begin{enumerate}
  \item the executing environment
  \item the global environment (i.e., the enclosing environment)
  \item the \texttt{package:<name>} environment of the last attached package
  \item ...
  \item the empty environment
\end{enumerate}
\end{frame}


\begin{frame}{Where does R find stuff?}
From inside functions \emph{defined in packages}?
\begin{enumerate}
  \item the executing environment
  \item the \texttt{namespace:<name>} environment 
  \item the \texttt{imports:<name>} environment
  \item the \texttt{namespace:base} environment
  \item the global environment (i.e., the enclosing environment)
  \item the \texttt{package:<name>} environment of the last attached package
  \item ...
  \item the empty environment
\end{enumerate}
\end{frame}



\begin{frame}{Where does R find stuff?}
Exported functions from packages have two binding environments!
\begin{itemize}
  \item the \texttt{namespace:<name>} environment 
  \item the \texttt{package:<name>} environment 
\end{itemize}
Both \texttt{::} and \texttt{:::} work.

\begin{center}
\includegraphics[height=.5\textheight]{from-Hadley/namespace-2binds.png}
\end{center}
\end{frame}


\begin{frame}{Where does R find stuff?}
\begin{center}
\includegraphics[height=.5\textheight]{from-Hadley/namespace-2binds.png}
\end{center}
But, only one enclosing environment: the \texttt{namespace:<name>} environment!

Thus, form inside a (package-) function, R first looks for imported and exported functions of that package!
\end{frame}




\begin{frame}{Where does R find stuff?}
Unexported functions from packages have one binding environment: the \texttt{namespace:<name>} environment 

\vspace{0.3cm}

Which is also the enclosing environment

\vspace{0.3cm}

Only \texttt{:::} works.
\end{frame}


\begin{frame}{Where does R find stuff?}
Where does R find functions from packages?
\begin{center}
\includegraphics[height=.5\textheight]{from-Hadley/namespaces.png}
\end{center}
\end{frame}



\begin{frame}{Enviroments}
You can do crazy things with environments. 

If you want to make use of reference
semantic (i.e., modify objects in place), use \href{https://CRAN.R-project.org/package=R6}{R6}


\vspace{1.5cm}


\metroset{block=fill} %grey blocks
\begin{block}{Programming advice}
Keep it simple, avoid chaos!
\end{block}
\end{frame}


\begin{frame}[plain]
\begin{center}
\Large Exercises \\

\vspace{1.5cm}

\includegraphics[height=.25\textheight]{exercises.jpg}
\end{center}
\end{frame}


% ----------------------------------------------------------------------------------------------------------------------
\section{Functionals}

\begin{frame}{Higher Order Functions}
Higher order functions are functions that either \textbf{take functions as input} or \textbf{return functions as output}.
\end{frame}


\begin{frame}{Functionals}
As defined by Hadley Wickham: A \textbf{functional} is a function that takes another function as an input. 
Common argument names are \texttt{FUN} or \texttt{f}. \\~\

\textbf{Examples}
\begin{itemize}
  \item \texttt{apply}-family
  \item \texttt{Reduce}, \texttt{Filter}
  \item \texttt{nlm}
  \item \texttt{optimize}
  \item ...
\end{itemize}
\end{frame}

\begin{frame}{\texttt{apply}-family}
The \texttt{apply}-family \emph{applies} a function repeatedly. 
This can be seen as an abstraction of a for loop, with the following advantages:
\begin{itemize}
  \item requires less code to write
  \item can be easier to read / understand
  \item does not store intermediate results
  \item no need to replace / grow
\end{itemize}
\end{frame}


\begin{frame}{\texttt{apply}-family}
The members of the \texttt{apply}-family in Base R are:
\begin{itemize}
  \item \texttt{lapply} vector / list $\rightarrow$ list
  \item \texttt{sapply} vector / list $\rightarrow$ vector (matrix)
  \item \texttt{apply} matrix / array / data.frame $\rightarrow$ vector (matrix)
  \item \texttt{tapply}, \texttt{by}
  \item \texttt{mapply}, \texttt{Map}
  \item \texttt{rapply}, \texttt{eapply}, \texttt{vapply} 
\end{itemize}
\end{frame}

\begin{frame}{\texttt{apply}-family}
A popular alternative from the tidyverse: \texttt{purrr}
\begin{itemize}
  \item \texttt{map} vector / list $\rightarrow$ list
  \item \texttt{map2} multiple vectors / lists $\rightarrow$ list
  \item ...
\end{itemize}
\end{frame}

\begin{frame}{\texttt{apply}-family}
Our focus: \texttt{lapply} and \texttt{Map}

\textbf{Why?}
\begin{itemize}
  \item Consistent output
  \item Fast
  \item No dependencies
  \item We want to understand R basics
\end{itemize}
\end{frame}


\subsubsection{lapply}

\begin{frame}[fragile]{lapply}
\texttt{lapply} takes mainly two arguments
\begin{itemize}
  \item[\texttt{X}] the input list/vector
  \item[\texttt{FUN}] the function that should be repeatedly applied
\end{itemize}
<<lapply1, echo=TRUE, results="markup", size="footnotesize">>=
example_list <- list(vec1 = c(1, 3, 4),
                     vec2 = c(4, 2, 10), 
                     vec3 = c(2, NA, 1))
lapply(example_list, FUN = mean)
@
\end{frame}

\begin{frame}[fragile]{lapply}
Other arguments can be passed through \texttt{lapply} via '\texttt{...}'.
<<lapply2, echo=TRUE, results="markup", size="footnotesize">>=
example_list <- list(vec1 = c(1, 3, 4),
                     vec2 = c(4, 2, 10), 
                     vec3 = c(2, NA, 1))
lapply(example_list, FUN = mean, na.rm = TRUE) 
@
\end{frame}

\begin{frame}[fragile]{lapply}
We can use our own functions as input.
<<lapply3, echo=TRUE, results="markup", size="footnotesize">>=
dropNAs <- function(x) {
  x[!is.na(x)]
}
lapply(example_list, FUN = dropNAs) 
@
\end{frame}

\begin{frame}[fragile]{lapply}
Anonymous functions can be used as input.
<<lapply4, echo=TRUE, results="markup", size="footnotesize">>=
lapply(example_list, FUN = function(x) x[!is.na(x)]) 
@
\end{frame}

\begin{frame}[fragile]{lapply}
Data.frames are lists, too.
<<lapply5, echo=TRUE, results="markup", size="footnotesize">>=
lapply(iris, FUN = class)
@
\end{frame}

\begin{frame}[fragile]{lapply}
Atomic vectors can be used as input, but often vectorization could be used instead.
<<lapply6, echo=TRUE, results="markup", size="footnotesize">>=
lapply(c(1, 2, 3), FUN = function(x) {
  paste0("ID", x)
})
@
\end{frame}



\subsubsection{Map}

\begin{frame}[fragile]{lapply}
Limitation of \texttt{lapply}:\\
Only a single list/vector can be supplied as input. \texttt{Map} is a generalization of \texttt{lapply}!
It is usually needed less often but a very powerful tool.
\end{frame}

\begin{frame}[fragile]{Map}
Works very similar to \texttt{lapply}, with a few differences:
\begin{itemize}
  \item Multiple input lists/vectors
  \item The list input should be named explicitly
  \item The order of the function and the list-input is switched
\end{itemize}
<<Map1, echo=TRUE, eval = FALSE>>=
list1 <- list(mtcars[1:2, 1:3], iris[1:2, c(1, 2, 5)])
list2 <- list(mtcars[3:4, 1:3], iris[3:4, c(1, 2, 5)])

Map(rbind, x = list1, y = list2)
@
\end{frame}

\begin{frame}[fragile]{Map}
<<Map2, echo=FALSE, eval = TRUE, results='markup'>>=
list1 <- list(mtcars[1:2, 1:3], iris[1:2, c(1, 2, 5)])
list2 <- list(mtcars[3:4, 1:3], iris[3:4, c(1, 2, 5)])

Map(rbind, list1, list2)
@
\end{frame}

\begin{frame}[fragile]{Map}
Again, anonymous functions can be supplied as input:

<<Map3, echo=TRUE, eval = FALSE>>=
list1 <- list(mtcars[1:2, 1:3], iris[1:2, c(1, 2, 5)])
list2 <- list(mtcars[3:4, 1:3], iris[3:4, c(1, 2, 5)])

Map(function(x, y) {
  rbind(x, y)
  }, 
  x = list1, y = list2)
@
\end{frame}

\subsection{Split \& Apply \& Combine}

\begin{frame}[fragile]{Split \& Apply \& Combine}
A common use case for the \texttt{apply-}family is the \textbf{Split \& Apply \& Combine} paradigm.
Here, we want to perform the same analyses for various subgroups in our data set:

\begin{itemize}
  \item \textbf{split} a data.frame or vector (\texttt{?split})
  \item \textbf{apply} computations on each split (\texttt{?lapply})
  \item \textbf{combine} the results (\texttt{?do.call})
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Split \& Apply \& Combine}
\begin{center}
\includegraphics[width=.75\textwidth]{split-apply-combine.png}
\end{center}
\end{frame}

\begin{frame}[fragile]{Split \& Apply \& Combine}

<<SAC1, echo=TRUE, eval = TRUE, results='markup'>>=
head(iris)
table(iris$Species)
@
\end{frame}

\begin{frame}[fragile]{Split \& Apply \& Combine}
Splitting the data set via a single (or multiple) grouping variables

<<SAC2, echo=TRUE, eval = TRUE, results='markup'>>=
data_list <- split(iris, f = iris$Species)
class(data_list)
length(data_list)
@
\end{frame}

\begin{frame}[fragile]{Split \& Apply \& Combine}
Apply the same computation to all data sets

<<SAC3, echo=TRUE, eval = TRUE, results='markup'>>=
out_list <- lapply(data_list, function(subdat) {
  mod <- lm(Sepal.Length ~ Sepal.Width, data = subdat)
  sum_mod <- summary(mod)
  out <- c(Intercept = coef(mod)[[1]], 
    Slope = coef(mod)[[2]],
    r2 = sum_mod$r.squared)
  round(out, 3)
})
@
\end{frame}

\begin{frame}[fragile]{Split \& Apply \& Combine}
<<SAC4, echo=TRUE, eval = TRUE, results='markup'>>=
out_list[["virginica"]]
@
\end{frame}

\begin{frame}[fragile]{Split \& Apply \& Combine}
Combine the results
<<SAC5, echo=TRUE, eval = TRUE, results='markup'>>=
do.call(rbind, out_list)
@
\end{frame}


\begin{frame}[plain]
\begin{center}
\Large Exercises \\

\vspace{1.5cm}

\includegraphics[height=.25\textheight]{exercises.jpg}
\end{center}
\end{frame}

% ----------------------------------------------------------------------------------------------------------------------
\section{Object Oriented Programming (S3)}

\begin{frame}{Object Oriented Programming}
Why?
\begin{itemize}
  \item User-friendly: same function for different objects (\texttt{summary()})
  \item Coder-friendly: implementation can depend on object
  \item Coder-friendly: easier to maintain \& extend
\end{itemize}
\end{frame}

\begin{frame}{Object Oriented Programming}
Basics
\begin{itemize}
  \item a \textbf{\textbf{class}} is a definition
  \item an object is an \textbf{instance} of a class.
  \item a \textbf{method} is specific implementation of procedure, and is associated with classes.
  \item \textbf{inheritance}: classes are organized in hierarchy. ``is-a-type-of''-relation.
  \item \textbf{method-dispatch}: the process of finding the correct method to apply for a specific object.
\end{itemize}
\end{frame}

\begin{frame}{Object Oriented Programming}
\textbf{Encapsulated OOP}
\begin{itemize}
  \item methods belong to objects or classes
  \item method calls look like \texttt{object.method(arg1, arg2)}
  \item most popular 
  \item python, \href{https://CRAN.R-project.org/package=R6}{R6}
\end{itemize}
\end{frame}

\begin{frame}{Object Oriented Programming}
\textbf{Functional OOP}
\begin{itemize}
  \item methods belong to \textbf{generics} (or generic functions)
  \item method calls look like \texttt{generic(object, arg1, arg2)}
  \item looks like a normal function
  \item internally build on functions
  \item S3
\end{itemize}
\end{frame}


\begin{frame}{Object Oriented Programming in R}
\begin{itemize}
  \item \textbf{S3}
  \item S4
  \item RC
  \item R6
  \item ...
\end{itemize}
\end{frame}

\subsection{What is S3?}

\begin{frame}{S3}
Compromise between interactive use, functional programming and object-oriented programming. 
\begin{itemize}
  \item ``naming conventions''
  \item used in base R
  \item flexible: new classes, new methods, new generics
\end{itemize}
\end{frame}

\begin{frame}{S3}
\begin{itemize}
  \item \texttt{class}-attribute
  \item generics and methods
  \item inheritance and dispatch
\end{itemize}
\end{frame}

\subsection{class}

\begin{frame}[fragile]{S3 - class}
A new class is made by adding an arbitrary \texttt{class} attribute to an object.
<<class, echo=TRUE, results='markup'>>=
object <- 1:10
class(object) <- "myClass"
attributes(object)
@
Very flexible! Use it wisely!
\end{frame}

\begin{frame}[fragile]{S3 - class}
<<class2, echo=TRUE, results="markup", size="footnotesize">>=
class(iris)
iris[1:4, 1:3]
@
\end{frame}

\begin{frame}[fragile]{S3 - class}
Changing the class changes the behavior!
<<class3, echo=TRUE, results="markup", size="footnotesize">>=
class(iris) <- "no data.frame"
class(iris)
iris[1:4, 1:3]
@
\end{frame}

\begin{frame}[fragile]{S3 - class}
Good practice: \emph{\textbf{constructor function}}
\begin{itemize}
  \item defines the structure of the class
  \item should be used to create objects of that class
\end{itemize}
<<constructor, echo=TRUE, results="markup", size="footnotesize">>=
myClass <- function(element1, element2){
  # validation of the elements
  structure(list(element1), 
            attribute1 = element2,
            class = "myClass")
}
@
Write a separate validation-function for computationally intensive validation.
\end{frame}

\subsection{Generics and Methods}

\begin{frame}[fragile]{S3 - Generics and Methods}
\begin{itemize}
  \item \textbf{methods} for a class belong to \textbf{generics}
  \item when a generic is called for a specific class, the corresponing method for that class will be used. 
  \item common generics are: \texttt{print()}, \texttt{plot()}, \texttt{summary()}, \texttt{anova()}
  \item same function, but different computation depending on object-class
\end{itemize}
<<generic, echo=TRUE, results='markup'>>=
body(print)
@
\end{frame}

\begin{frame}[fragile]{S3 - Generics and Methods}
Creating a new method (for an existing generic):
<<method, echo=TRUE, results="markup", size="footnotesize">>=
print.myClass <- function(x, ...){
  cat("This is a myClass-print:\n")
  cat(round(c(nValues = length(x), 
                mean = mean(x), 
                SD = sd(x)), 3), ...)
}
my_object <- 1:5
class(my_object) <- "myClass"
print(my_object)
@
\end{frame}

\begin{frame}[fragile]{S3 - Generics and Methods}
Good practices (enforced for packages on CRAN):
\begin{itemize}
  \item A method must have all the arguments of the generic,
including \texttt{...} if the generic does.
  \item A method must have arguments in exactly the same order as
the generic.
  \item If the generic specifies defaults, all methods should use the
same defaults.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{S3 - Generics and Methods}
Inspect the generic!
<<inspect, echo=TRUE, results="markup", size="footnotesize">>=
formalArgs(print)
formalArgs(summary)
@
\end{frame}

\begin{frame}[fragile]{S3 - Generics and Methods}
Creating a new generic:
<<method2, echo=TRUE, results="markup", size="footnotesize">>=
center <- function(x, ...)
  UseMethod("center")

center.myClass <- function(x, ...){
  print("centering myClass:\n")
  return(x - mean(x))
}

center(my_object)
@
\end{frame}

\subsection{inheritance and dispatch}

\begin{frame}[fragile]{S3 - Inheritance and Dispatch}
<<data, echo=FALSE, eval = TRUE>>=
pisa_file <- file.path(dirname(getwd()), "data/pisaPlus_CF.RDS")
pisa <- readRDS(pisa_file)
@
Objects can have more than one class
<<inheritance1, echo=TRUE, results='markup', size = "footnotesize">>=
my_model <- glm(as.factor(books) ~ pared, data = pisa, 
                family = "binomial")
class(my_model)
class(my_model) == "lm"
inherits(my_model, "lm")
@
Good practice: hierachical inheritance (subclass and superclass)
\end{frame}

\begin{frame}[fragile]{S3 - Inheritance and Dispatch}
When a method is not available for a (sub)class, the next available method (i.e., for the supperclass) will be used.

<<inheritance2, echo=TRUE, results="markup", size = "footnotesize">>=
"variable.names.glm" %in% methods(class = "glm")
"variable.names.lm" %in% methods(class = "lm")
variable.names(my_model)
@

\end{frame}

\begin{frame}[plain]
\begin{center}
\Large Exercises \\

\vspace{1.5cm}

\includegraphics[height=.25\textheight]{exercises.jpg}
\end{center}
\end{frame}

% -----------------------------------------------------------------------------------------------------------------
\section{Version Controlling (Git + Github)}

\begin{frame}{Version Controlling}
\begin{itemize}
  \item Motivation
  \item Setup
  \item Work flow
  \item Recommendations
  \item Resources
\end{itemize}
\end{frame}

\subsection{Motivation}

\begin{frame}{Motivation}
\begin{center}
\includegraphics[height=.75\textheight]{why_version_control.jpg}
\end{center}
\end{frame}

\begin{frame}{Motivation}
\begin{itemize}
  \item Implementation of long term change history 
  \begin{itemize}
  \item No ridiculous file names
  \item No archive subfolder
  \item Always perfect overview of file history and changes
  \end{itemize}
  \item Collaborations
  \begin{itemize}
  \item What has changed?
  \item Who has changed it?
  \item Documentation of changes
  \item Parallel working possible (merging)
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{But...}
\begin{center}
\includegraphics[height=.75\textheight]{git_no_idea.png}
\end{center}
\end{frame}

\subsection{Setup}

\begin{frame}{Setup}
See the workshop preparation materials
\end{frame}

\subsection{Work flow}

\begin{frame}{Work flow 1}
\textbf{Creating a repository}
\begin{itemize}
  \item Create an \textbf{online repository} (e.g. on Github)
  \begin{itemize}
    \item Use an R specific \texttt{.gitignore}
    \item Initialize with a short readme (\texttt{.md})
  \end{itemize}
  \item Clone the repository to your local machine via RStudio
  \item An R-Project is added automatically to the existing repository
\end{itemize}
\end{frame}

\begin{frame}{Excursion: gitignore}
\begin{itemize}
  \item Plain text file
  \item Which files should not be tracked by git? \\
  $\rightarrow$ These then only exist locally in their current version!
  \item Options
  \begin{itemize}
    \item Single files
    \item Folder
    \item Specific data types
    \item Combinations of the above
  \end{itemize}
  \item Use cases
    \begin{itemize}
    \item Large files (Data, images, ...)
    \item Auxiliary files (e.g. created during latex compilation)
  \end{itemize}
\end{itemize}
\end{frame}


\begin{frame}{Work flow 2}
\textbf{Working with an existing repository}
\begin{itemize}
  \item Before working: Synch your local repo (\textbf{Pull} or \textbf{clone})
  \item Perform changes in your local repository \\
  $\rightarrow$ Create/modify/delete files
  \item \textbf{Stage} your changes
  \item \textbf{Commit} your changes (aka new version)
  \item \textbf{Push} your changes (online repository is updated)
\end{itemize}
\end{frame}

\begin{frame}{Excursion: mergen}
\textbf{Conflicts between different updated versions}
\begin{itemize}
  \item Common when working collaborativley
  \item Discrepancies between your own different local repos
  $\rightarrow$ Git communicates these and indicates conflicts
  \item Select the desired changes
  \item Stage selection, commit and push
\end{itemize}
\end{frame}

\begin{frame}{Excursion: Branches}
\textbf{Multiple parallel versions of a project within one repository}
\begin{itemize}
  \item e.g. one stable and one development branch
  \item Only certrain modifications should be made in the stable branch
  \item \textbf{Note}: RStudio GUI has limited support for this
\end{itemize}
\end{frame}



\subsection{Recommendations}

\begin{frame}{Recommendations}
\begin{itemize}
  \item Keep it simple! 
  \begin{itemize}
    \item If not necessary, no branches/forks/pull requests
  \end{itemize}
  \item Have meaningful commits
  \item Keep it lean (no big files)
\end{itemize}
\end{frame}

\subsection{Resources}

\begin{frame}{Resources}
Git (+ R) Resources
\begin{itemize}
\item Small Intro (\url{https://r-bio.github.io/intro-git-rstudio/})
\item Happy Git with R (\url{https://happygitwithr.com/})
\item R Packages and Git (\url{https://r-pkgs.org/git.html})
\item Git Book (\url{http://git-scm.com/book/en/v2})
\end{itemize}

\end{frame}


% -----------------------------------------------------------------------------------------------------------------
\section{R Packages}

\begin{frame}{Motivation}
\begin{itemize}
  \item It is incredibly easy!
  \item It makes your code easier accessible (for others and yourself)
  \item It provides a great framework for documenting your code 
  \item It provides great tools for testing your code
  \item It is a form of scientific output (packages can be cited)
\end{itemize}
\end{frame}

\begin{frame}{Setup}
Use \texttt{usethis} and/or \texttt{RStudio} to set up everything.
\begin{itemize}
  \item Create a regular Github Repository
  \item Clone the repository regularly 
  \item Use \texttt{usethis::use\_package(getwd())} to create the minimal package structure
  \item Use \texttt{usethis} if you want to add more specific architecture
\end{itemize}
\end{frame}

\begin{frame}{R functions}
Your actual code lives in the \texttt{R} folder. 
\begin{itemize}
  \item Write small functions which do one specific thing
  \item Organize your functions logically
  \item Avoid very long scripts
\end{itemize}
\end{frame}


\begin{frame}{Using other packages}
If you want to use another package in your source code, add it to the Imports-Field in your description file and use its functions using \texttt{package::function}. 
\end{frame}

\begin{frame}{Documentation}
Use \texttt{roxygen2} to document your code and to manage your namespace.
\end{frame}


\begin{frame}{Testing}
Use \texttt{testthat} for automated testing. This has multiple advantages:
\begin{itemize}
  \item Good test coverage serves as a quality attribute of a good and stable package
  \item Modifying existing code becomes much easier
  \item Your code becomes more robust
  \item It helps you sleep at night
\end{itemize}
\end{frame}


\begin{frame}{Resources}
Writing R packages
\begin{itemize}
\item Writing R Extensions (\url{https://cloud.r-project.org/doc/manuals/r-release/R-exts.html})
\item R Packages (\url{https://r-pkgs.org/})
\end{itemize}
\end{frame}

% -----------------------------------------------------------------------------------------------------------------
\section{Wrap Up}

\begin{frame}{General Advice}
\begin{itemize}
\item Try to always learn new things about R and / or programming
\item Try to automate as much as possible
\item If you are re-using code regularly, write a package!
\item Learn from masters
\item Rewrite important code - the first attempt is usually not the best approach
\end{itemize}
\end{frame}


\begin{frame}{Literature Recommendations}
R Resources
\begin{itemize}
\item Advanced R Ed. 1 (\url{http://adv-r.had.co.nz/})
\item Advanced R Ed. 2 (\url{https://adv-r.hadley.nz/})
\item Notes on Functionals (\url{https://www.stat.umn.edu/geyer/8054/notes/functional.html})
\item R language definition (\url{https://cloud.r-project.org/doc/manuals/r-release/R-lang.html})
\item R Inferno (\url{https://www.burns-stat.com/pages/Tutor/R_inferno.pdf})
\item R Packages (\url{https://r-pkgs.org/})
\item Clean Code (\url{https://enos.itcollege.ee/~jpoial/oop/naited/Clean\%20Code.pdf})
\end{itemize}



\end{frame}


\begin{frame}[plain]

\begin{center}
\Large Thank you for your attention!

\visible<2>{Questions? Remarks?}
\end{center}

\end{frame}

\end{document}
