\documentclass{beamer}
%\documentclass[xcolor=table]{beamer}

%\usepackage{graphicx}
%\usepackage{color}

%\usepackage{alltt}
%\usepackage{hyperref}

%\usepackage{array}
%\usepackage[originalparameters]{ragged2e} 

% kable packages
%\usepackage{longtable}
%\usepackage{array}
%\usepackage{multirow}
%\usepackage{wrapfig}
%\usepackage{float}
%\usepackage{colortbl}
%\usepackage{pdflscape}
%\usepackage{tabu}
%\usepackage{threeparttable}
%\usepackage{threeparttablex}
%\usepackage[normalem]{ulem}
%\usepackage{makecell}

%\usepackage{amsmath}
%\usepackage{booktabs}
%\usepackage[ansinew]{inputenc}
%\usepackage[utf8]{inputenc}
%\usepackage[ngerman, english]{babel}

%\usepackage{bm}

\usepackage[T1]{fontenc}
\usepackage{textcomp}

\usetheme{metropolis}   

<<r setup, echo=FALSE, message=FALSE, results='hide'>>=
suppressPackageStartupMessages({
  library(knitr)
})

knit_theme$set("acid")
opts_chunk$set(message=FALSE, warning=FALSE)
opts_chunk$set(results="hide")
opts_chunk$set(strip.white = TRUE)
opts_chunk$set(size = "small")
opts_chunk$set(comment = "#")

## R Setup
#load("~/Documents/Workshops/FDZ_Reporting/IQB-LV-2011_SchuelerInnen-Eltern_CF.rda")


# Farben
mLightBrown<-"#EB811B"
econBlue<-"#008BBC"
econRed<-"#C10534"
econBlueD<-"#3E647D"
econRedD<-"#90353B"
@


\begin{document}


\title{Advanced Programming with R}
\institute{Zurich University}

\author[Dries Debeer \& Benjamin Becker]{Dries Debeer \& Benjamin Becker}
\date{15. October 2021}


\begin{frame}
\titlepage
\end{frame}
\addtocounter{framenumber}{-1}

% -----------------------------------------------------------------------------------------------------------------
\section{Introduction}

\begin{frame}{Introduction}
\begin{columns}[t]
\begin{column}{.475\textwidth}
    \textbf{Who are we?} 
    
    \vspace{0.3cm}
    
    \textcolor{mLightBrown}{Dries Debeer} \\
    
    \vspace{0.2cm}
    
    Senior Researcher at itec (imec research group at KU Leuven)
\end{column}
\begin{column}{.475\textwidth}
    \textbf{} 
    
    \vspace{0.3cm}
    
    \textcolor{mLightBrown}{Benjamin Becker} \\
    
    \vspace{0.2cm}
    
    Researcher at IQB (Statistics Department)
    
\end{column}
\end{columns}

\vspace{0.2cm}

\begin{columns}[t]
\begin{column}{.475\textwidth}
\href{https://github.com/ddebeer/scDIFtest}{scDIFtest}, \href{https://github.com/ddebeer/permimp}{permimp}, \href{https://github.com/beckerbenj/eatATA}{eatATA}, \href{https://CRAN.R-project.org/package=mstDIF}{mstDIF}
  	
\end{column}
\begin{column}{.475\textwidth}
\href{https://github.com/beckerbenj/eatGADS}{eatGADS}, \href{https://github.com/beckerbenj/eatDB}{eatDB}, \href{https://github.com/beckerbenj/eatATA}{eatATA}, \href{https://github.com/beckerbenj/pisaRT}{pisaRT}

  \end{column}
\end{columns}

\vspace{0.3cm}

\begin{columns}[t]
\begin{column}{.475\textwidth}

\href{mailto:dries.debeer@kuleuven.be}{dries.debeer@kuleuven.be}
  	
\end{column}
  \begin{column}{.475\textwidth}

\href{b.becker@iqb.hu-berlin.de}{b.becker@iqb.hu-berlin.de}

  \end{column}
\end{columns}

\vspace{1.5em}
\end{frame}

\begin{frame}{Introduction}
\textbf{Who are you?}
\begin{enumerate}%\itemsep0em
	\item Occupation, employer?
	\item Previous knowledge and experience
	\begin{itemize}
	  \item with R?
	  \item with other programming languages?
	\end{itemize}
	\item Specific interest/motivation for this workshop?
\end{enumerate}
\end{frame}

\subsection{Goal}

\begin{frame}{What do we expect from you?}

\textbf{You ...}
\begin{itemize}
  \item are a frequent R user (e.g. for data wrangling/analyses/plots)
  \item have a rough understanding of R as a programming language\\
  $\rightarrow$ e.g. you have already written some R functions yourself
  \item are interested in learning more about the intricacies of R 
\end{itemize}
\end{frame}

\begin{frame}{Goal of this workshop}

\textbf{A deeper dive into R as a Programming language}
\begin{itemize}
  \item Better understanding of how R works as a programming language
  \item Better understanding of how larger programming projects can/should be structured
  \item Practical Git skills
  \item Practical R package building skills
\end{itemize}
\end{frame}

\subsection{Agenda}

\begin{frame}{Agenda}
\begin{itemize}
  \item Scoping \& Environments
  \item Functionals \& Split-Apply Paradigm
\end{itemize} \\ ~ \

- \textit{Lunch Break} -\\ ~ \

\begin{itemize}
  \item Object Orientation (S3)
  \item Packages \& Version Controlling
\end{itemize}
\end{frame}


\end{frame}

% -----------------------------------------------------------------------------------------------------------------
\section{Scoping \& Environments}

\subsection{Environments}

\begin{frame}{Environments}
Like boxes, containing objects.
\begin{center}
\includegraphics[height=.4\textheight]{envir.JPG}
\end{center}
A bit simplified: If a function is called, its own environment is created with its parent being the environment from which it was called.
\end{frame}


\begin{frame}[fragile]{Environments}
<<echo=TRUE, results='markup'>>=
simple_fun <- function(){
  a <- 1
  b <- "a"
  environment()
}
a <- simple_fun()
rlang::env_print(a)
@
\end{frame}

\subsection{Scoping}

\begin{frame}{Scoping}
Where does R find things?
\begin{itemize}
  \item Argument matching (name, place...)
  \item Current environment
  \item Parent environment
\end{itemize}

\metroset{block=fill} %grey blocks
\begin{block}{Programming advice}
Keep it simple, this can create chaos!
\end{block}
\end{frame}

\begin{frame}[fragile]{Scoping}
<<echo=TRUE, results='asis'>>=
add_things2 <- function(x) {
  x + 10 + y
}
add_things2(2)
y <- 100
add_things2(2)
@
\end{frame}

% ----------------------------------------------------------------------------------------------------------------------
\section{Functionals}

\begin{frame}{Higher Order Functions}
Higher order functions are functions that either \textbf{take functions as input} or \textbf{return functions as output}.
\end{frame}


\begin{frame}{Functionals}
As defined by Hadley Wickham: A \textbf{functional} is a function that takes another function as an input. 
Common argument names are \texttt{FUN} or \texttt{f}. \\~\

\textbf{Examples}
\begin{itemize}
  \item \texttt{apply}-family
  \item \texttt{Reduce}, \texttt{Filter}
  \item \texttt{nlm}
  \item \texttt{optimize}
  \item ...
\end{itemize}
\end{frame}

\begin{frame}{\texttt{apply}-family}
The \texttt{apply}-family \emph{applies} a function repeatedly. 
This can be seen as an abstraction of a for loop, with the following advantages:
\begin{itemize}
  \item requires less code to write
  \item can be easier to read / understand
  \item does not store intermediate results
  \item no need to replace / grow
\end{itemize}
\end{frame}


\begin{frame}{\texttt{apply}-family}
The members of the \texttt{apply}-family in Base R are:
\begin{itemize}
  \item \texttt{lapply} vector / list $\rightarrow$ list
  \item \texttt{sapply} vector / list $\rightarrow$ vector (matrix)
  \item \texttt{apply} matrix / array / data.frame $\rightarrow$ vector (matrix)
  \item \texttt{tapply}, \texttt{by}
  \item \texttt{mapply}, \texttt{Map}
  \item \texttt{rapply}, \texttt{eapply}, \texttt{vapply} 
\end{itemize}
\end{frame}

\begin{frame}{\texttt{apply}-family}
A popular alternative from the tidyverse: \texttt{purrr}
\begin{itemize}
  \item \texttt{map} vector / list $\rightarrow$ list
  \item \texttt{map2} multiple vectors / lists $\rightarrow$ list
  \item ...
\end{itemize}
\end{frame}

\begin{frame}{\texttt{apply}-family}
Our focus: \texttt{lapply} and \texttt{Map}

\textbf{Why?}
\begin{itemize}
  \item Consistent output
  \item Fast
  \item No dependencies
  \item We want to understand R basics
\end{itemize}
\end{frame}


\subsubsection{lapply}

\begin{frame}[fragile]{lapply}
\texttt{lapply} takes mainly two arguments
\begin{itemize}
  \item[\texttt{X}] the input list/vector
  \item[\texttt{FUN}] the function that should be repeatedly applied
\end{itemize}
<<lapply1, echo=TRUE, results="markup", size="footnotesize">>=
example_list <- list(vec1 = c(1, 3, 4),
                     vec2 = c(4, 2, 10), 
                     vec3 = c(2, NA, 1))
lapply(example_list, FUN = mean)
@
\end{frame}

\begin{frame}[fragile]{lapply}
Other arguments can be passed through \texttt{lapply} via '\texttt{...}'.
<<lapply2, echo=TRUE, results="markup", size="footnotesize">>=
example_list <- list(vec1 = c(1, 3, 4),
                     vec2 = c(4, 2, 10), 
                     vec3 = c(2, NA, 1))
lapply(example_list, FUN = mean, na.rm = TRUE) 
@
\end{frame}

\begin{frame}[fragile]{lapply}
We can use our own functions as input.
<<lapply3, echo=TRUE, results="markup", size="footnotesize">>=
dropNAs <- function(x) {
  x[!is.na(x)]
}
lapply(example_list, FUN = dropNAs) 
@
\end{frame}

\begin{frame}[fragile]{lapply}
Anonymous functions can be used as input.
<<lapply4, echo=TRUE, results="markup", size="footnotesize">>=
lapply(example_list, FUN = function(x) x[!is.na(x)]) 
@
\end{frame}

\begin{frame}[fragile]{lapply}
Data.frames are lists, too.
<<lapply5, echo=TRUE, results="markup", size="footnotesize">>=
lapply(iris, FUN = class)
@
\end{frame}

\begin{frame}[fragile]{lapply}
Atomic vectors can be used as input, but often vectorization could be used instead.
<<lapply6, echo=TRUE, results="markup", size="footnotesize">>=
lapply(c(1, 2, 3), FUN = function(x) {
  paste0("ID", x)
})
@
\end{frame}



\subsubsection{Map}

\begin{frame}[fragile]{lapply}
Limitation of \texttt{lapply}:\\
Only a single list/vector can be supplied as input. \texttt{Map} is a generalization of \texttt{lapply}!
It is usually needed less often but a very powerful tool.
\end{frame}

\begin{frame}[fragile]{Map}
Works very similar to \texttt{lapply}, with a few differences:
\begin{itemize}
  \item Multiple input lists/vectors
  \item The list input should be named explicitly
  \item The order of the function and the list-input is switched
\end{itemize}
<<Map1, echo=TRUE, eval = FALSE>>=
list1 <- list(mtcars[1:2, 1:3], iris[1:2, c(1, 2, 5)])
list2 <- list(mtcars[3:4, 1:3], iris[3:4, c(1, 2, 5)])

Map(rbind, x = list1, y = list2)
@
\end{frame}

\begin{frame}[fragile]{Map}
<<Map2, echo=FALSE, eval = TRUE, results='markup'>>=
list1 <- list(mtcars[1:2, 1:3], iris[1:2, c(1, 2, 5)])
list2 <- list(mtcars[3:4, 1:3], iris[3:4, c(1, 2, 5)])

Map(rbind, list1, list2)
@
\end{frame}

\begin{frame}[fragile]{Map}
Again, anonymous functions can be supplied as input:

<<Map3, echo=TRUE, eval = FALSE>>=
list1 <- list(mtcars[1:2, 1:3], iris[1:2, c(1, 2, 5)])
list2 <- list(mtcars[3:4, 1:3], iris[3:4, c(1, 2, 5)])

Map(function(x, y) {
  rbind(x, y)
  }, 
  x = list1, y = list2)
@
\end{frame}

\subsection{Split \& Apply \& Combine}

\begin{frame}[fragile]{Split \& Apply \& Combine}
A common use case for the \texttt{apply-}family is the \textbf{Split \& Apply \& Combine} paradigm.
Here, we want to perform the same analyses for various subgroups in our data set:

\begin{itemize}
  \item \textbf{split} a data.frame or vector (\texttt{?split})
  \item \textbf{apply} computations on each split (\texttt{?lapply})
  \item \textbf{combine} the results (\texttt{?sapply}, \texttt{?do.call})
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Split \& Apply \& Combine}
\begin{center}
\includegraphics[width=.75\textwidth]{split-apply-combine.png}
\end{center}
\end{frame}

\begin{frame}[fragile]{Split \& Apply \& Combine}

<<SAC1, echo=TRUE, eval = TRUE, results='markup'>>=
head(iris)
table(iris$Species)
@
\end{frame}

\begin{frame}[fragile]{Split \& Apply \& Combine}
Splitting the data set via a single (or multiple) grouping variables

<<SAC2, echo=TRUE, eval = TRUE, results='markup'>>=
data_list <- split(iris, f = iris$Species)
class(data_list)
length(data_list)
@
\end{frame}

\begin{frame}[fragile]{Split \& Apply \& Combine}
Apply the same computation to all data sets

<<SAC3, echo=TRUE, eval = TRUE, results='markup'>>=
out_list <- lapply(data_list, function(subdat) {
  mod <- lm(Sepal.Length ~ Sepal.Width, data = subdat)
  sum_mod <- summary(mod)
  out <- c(Intercept = coef(mod)[[1]], 
    Slope = coef(mod)[[2]],
    r2 = sum_mod$r.squared)
  round(out, 3)
})
@
\end{frame}

\begin{frame}[fragile]{Split \& Apply \& Combine}
<<SAC4, echo=TRUE, eval = TRUE, results='markup'>>=
out_list[["virginica"]]
@
\end{frame}

\begin{frame}[fragile]{Split \& Apply \& Combine}
Combine the results
<<SAC5, echo=TRUE, eval = TRUE, results='markup'>>=
do.call(rbind, out_list)
@
\end{frame}


\begin{frame}[plain]
\begin{center}
\Large Exercises \\

\vspace{1.5cm}
\includegraphics[height=.25\textheight]{exercises.jpg}
\end{center}
\end{frame}

% ----------------------------------------------------------------------------------------------------------------------
\section{Object Oriented Programming (S3)}

\begin{frame}{Object Oriented Programming}
Why?
\begin{itemize}
  \item User-friendly: same function for different objects (\texttt{summary()})
  \item Coder-friendly: implementation can depends on object
  \item Coder-friendly: easier to maintain, extend
\end{itemize}
\end{frame}

\begin{frame}{Object Oriented Programming}
Basics
\begin{itemize}
  \item a \emph{class} is a definition
  \item an object is an \emph{instance} of a class.
  \item a \emph{method} is a procedure that behaves differently depending of the class it is applied to.
  \item \emph{inheritance}: classes are organized in hierarchy. ``is-a-type-of''-relation. 
\end{itemize}
\end{frame}

\begin{frame}{Object Oriented Programming in R}
\begin{itemize}
  \item \textbf{S3}
  \item S4
  \item RC
  \item R6
  \item ...
\end{itemize}
\end{frame}

\subsection{What is S3?}

\begin{frame}{S3}
Compromise between interactive use, functional programming and object-oriented programming. 
\begin{itemize}
  \item ``naming conventions''
  \item used in base R
  \item flexible: new classes, new methods
\end{itemize}
\end{frame}

\begin{frame}{S3}
\begin{itemize}
  \item \texttt{class}-attribute
  \item generics and methods
  \item inheritance and dispatch
\end{itemize}
\end{frame}

\subsection{class}

\begin{frame}[fragile]{S3 - class}
A new class is made by adding an arbitrary \texttt{class} attribute to an object.
<<class, echo=TRUE, results='markup'>>=
object <- 1:10
class(object) <- "myClass"
attributes(object)
@
Very flexible! Use it wisely!
\end{frame}

\begin{frame}[fragile]{S3 - class}
<<class2, echo=TRUE, results="markup", size="footnotesize">>=
class(iris)
iris[1:4, 1:3]
@
\end{frame}

\begin{frame}[fragile]{S3 - class}
Changing the class changes the behavior!
<<class3, echo=TRUE, results="markup", size="footnotesize">>=
class(iris) <- "no data.frame"
class(iris)
iris[1:4, 1:3]
@
\end{frame}

\begin{frame}[fragile]{S3 - class}
Good practice: \emph{\textbf{constructor function}}
\begin{itemize}
  \item defines the structure of the class
  \item should be used to create objects of that class
\end{itemize}
<<constructor, echo=TRUE, results="markup", size="footnotesize">>=
myClass <- function(element1, element2){
  # validation of the elements
  structure(list(element1), 
            attribute1 = element2,
            class = "myClass")
}
@
Write a separate validation-function for computationally intensive validation.
\end{frame}

\subsection{Generics and Methods}

\begin{frame}[fragile]{S3 - Generics and Methods}
\begin{itemize}
  \item \emph{methods} for a class belong to \emph{generics}
  \item when a generic is called for a specific class, the corresponing method for that class will be used. 
  \time common generics are: \texttt{print()}, \texttt{plot()}, \texttt{summary()}, \texttt{anova()}
  \item same function, but different computation depending on object-class
\end{itemize}
<<generic, echo=TRUE, results='markup'>>=
body(print)
@
\end{frame}

\begin{frame}[fragile]{S3 - Generics and Methods}
Creating a new method (for an existing generic):
<<method, echo=TRUE, results="markup", size="footnotesize">>=
print.myClass <- function(x, ...){
  cat("This is a myClass-print:\n")
  cat(round(c(nValues = length(x), 
                mean = mean(x), 
                SD = sd(x)), 3), ...)
}
my_object <- 1:5
class(my_object) <- "myClass"
print(my_object)
@
\end{frame}

\begin{frame}[fragile]{S3 - Generics and Methods}
Good practices (enforced for packages on CRAN):
\begin{itemize}
  \item A method must have all the arguments of the generic,
including \texttt{...} if the generic does.
  \item A method must have arguments in exactly the same order as
the generic.
  \item If the generic specifies defaults, all methods should use the
same defaults.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{S3 - Generics and Methods}
Inspect the generic!
<<inspect, echo=TRUE, results="markup", size="footnotesize">>=
formalArgs(print)
formalArgs(summary)
@
\end{frame}

\begin{frame}[fragile]{S3 - Generics and Methods}
Creating a new generic:
<<method2, echo=TRUE, results="markup", size="footnotesize">>=
center <- function(x, ...)
  UseMethod("center")

center.myClass <- function(x, ...){
  print("centering myClass:\n")
  return(x - mean(x))
}

center(my_object)
@
\end{frame}

\subsection{inheritance and dispatch}

\begin{frame}[fragile]{S3 - Inheritance and Dispatch}
<<data, echo=FALSE, eval = TRUE>>=
pisa_file <- file.path(dirname(getwd()), "data/pisaPlus_CF.RDS")
pisa <- readRDS(pisa_file)
@
Objects can have more than one class
<<inheritance1, echo=TRUE, results='markup', size = "footnotesize">>=
my_model <- glm(as.factor(books) ~ pared, data = pisa, 
                family = "binomial")
class(my_model)
class(my_model) == "lm"
inherits(my_model, "lm")
@
Good practice: hierachical inheritance (subclass and superclass)
\end{frame}

\begin{frame}[fragile]{S3 - Inheritance and Dispatch}
When a method is not available for a (sub)class, the next available method (i.e., for the supperclass) will be used.

<<inheritance2, echo=TRUE, results="markup", size = "footnotesize">>=
"variable.names.glm" %in% methods(class = "glm")
"variable.names.lm" %in% methods(class = "lm")
variable.names(my_model)
@

\end{frame}

\begin{frame}[plain]
\begin{center}
\Large Exercises \\

\vspace{1.5cm}
\includegraphics[height=.25\textheight]{exercises.jpg}
\end{center}
\end{frame}

% -----------------------------------------------------------------------------------------------------------------
\section{Version Controlling (Git + Github)}

\begin{frame}{Version Controlling}
\begin{itemize}
  \item Motivation
  \item Setup
  \item Work flow
  \item Recommendations
  \item Resources
\end{itemize}
\end{frame}

\subsection{Motivation}

\begin{frame}{Motivation}
\begin{center}
\includegraphics[height=.75\textheight]{why_version_control.jpg}
\end{center}
\end{frame}

\begin{frame}{Motivation}
\begin{itemize}
  \item Implementation of long term change history 
  \begin{itemize}
  \item No ridiculous file names
  \item No archive subfolder
  \item Always perfect overview of file history and changes
  \end{itemize}
  \item Collaborations
  \begin{itemize}
  \item What has changed?
  \item Who has changed it?
  \item Documentation of changes
  \item Parallel working possible (merging)
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{But...}
\begin{center}
\includegraphics[height=.75\textheight]{git_no_idea.png}
\end{center}
\end{frame}

\subsection{Setup}

\begin{frame}{Setup}
See the workshop preparation materials
\end{frame}

\subsection{Work flow}

\begin{frame}{Work flow 1}
\textbf{Creating a repository}
\begin{itemize}
  \item Create an \textbf{online repository} (e.g. on Github)
  \begin{itemize}
    \item Use an R specific \texttt{.gitignore}
    \item Initialize with a short readme (\texttt{.md})
  \end{itemize}
  \item Clone the repository to your local machine
  \item An R-Project is added automatically to the existing repository
\end{itemize}
\end{frame}

\begin{frame}{Excursion: gitignore}
\begin{itemize}
  \item Plain text file
  \item Which files should not be tracked by git? \\
  $\rightarrow$ These then only exist locally in their current version!
  \item Options
  \begin{itemize}
    \item Single files
    \item Folder
    \item Specific data types
    \item Combinations of the above
  \end{itemize}
  \item Use cases
    \begin{itemize}
    \item Large files (Data, images, ...)
    \item Auxiliary files (e.g. created during latex compilation)
  \end{itemize}
\end{itemize}
\end{frame}


\begin{frame}{Work flow 2}
\textbf{Working with an existing repository}
\begin{itemize}
  \item Before working: Synch your local repo (\textbf{Pull} or \textbf{clone})
  \item Perform changes in your local repository \\
  $\rightarrow$ Create/modify/delete files
  \item \textbf{Stage} your changes
  \item \textbf{Commit} your changes (aka new version)
  \item \textbf{Push} your changes (online repository is updated)
\end{itemize}
\end{frame}

\begin{frame}{Excursion: mergen}
\textbf{Conflicts between different updated versions}
\begin{itemize}
  \item Common when working collaborativley
  \item Discrepancies between your own different local repos
  $\rightarrow$ Git communicates these and indicates conflicts
  \item Select the desired changes
  \item Stage selection, commit and push
\end{itemize}
\end{frame}

\begin{frame}{Excursion: Branches}
\textbf{Multiple parallel versions of a project within one repository}
\begin{itemize}
  \item e.g. one stable and one development branch
  \item Only certrain modifications should be made in the stable branch
  \item \textbf{Note}: RStudio GUI has limited support for this
\end{itemize}
\end{frame}



\subsection{Recommendations}

\begin{frame}{Recommendations}
\begin{itemize}
  \item Keep it simple! 
  \begin{itemize}
    \item If not necessary, no branches/forks/pull requests
  \end{itemize}
  \item Have meaningful commits
  \item Keep it lean (no big files)
\end{itemize}
\end{frame}

\subsection{Resources}

\begin{frame}{Resources}
Git (+ R) Resources
\begin{itemize}
\item Small Intro (\url{https://r-bio.github.io/intro-git-rstudio/})
\item Happy Git with R (\url{https://happygitwithr.com/})
\item R Packages and Git (\url{https://r-pkgs.org/git.html})
\item Git Book (\url{http://git-scm.com/book/en/v2})
\end{itemize}

\end{frame}


% -----------------------------------------------------------------------------------------------------------------
\section{R Packages}

\begin{frame}{Motivation}
\begin{itemize}
  \item It is incredibly easy!
  \item It makes your code easier accessible (for others and yourself)
  \item It provides a great framework for documenting your code 
  \item It provides great tools for testing your code
  \item It is a form of scientific output (packages can be cited)
\end{itemize}
\end{frame}

\begin{frame}{Setup}
Use \texttt{usethis} and/or \texttt{RStudio} to set up everything.
\begin{itemize}
  \item Create a regular Github Repository
  \item Clone the repository regularly 
  \item Use \texttt{usethis::use\_package(getwd())} to create the minimal package structure
  \item Use \texttt{usethis} if you want to add more specific architecture
\end{itemize}
\end{frame}

\begin{frame}{R functions}
Your actual code lives in the \texttt{R} folder. 
\begin{itemize}
  \item Write small functions which do one specific thing
  \item Organize your functions logically
  \item Avoid very long scripts
\end{itemize}
\end{frame}


\begin{frame}{Using other packages}
If you want to use another package in your source code, add it to the Imports-Field in your description file and use its functions using \texttt{package::function}. 
\end{frame}

\begin{frame}{Documentation}
Use \texttt{roxygen2} to document your code and to manage your namespace.
\end{frame}


\begin{frame}{Testing}
Use \texttt{testthat} for automated testing. This has multiple advantages:
\begin{itemize}
  \item Good test coverage serves as a quality attribute of a good and stable package
  \item Modifying existing code becomes much easier
  \item Your code becomes more robust
  \item It helps you sleep at night
\end{itemize}
\end{frame}


\begin{frame}{Resources}
Writing R packages
\begin{itemize}
\item Writing R Extensions (\url{https://cloud.r-project.org/doc/manuals/r-release/R-exts.html})
\item R Packages (\url{https://r-pkgs.org/})
\end{itemize}
\end{frame}

% -----------------------------------------------------------------------------------------------------------------
\section{Wrap Up}

\begin{frame}{General Advice}
\begin{itemize}
\item Try to always learn new things about R and / or programming
\item Try to automate as much as possible
\item If you are re-using code regularly, write a package!
\item Learn from masters
\item Rewrite important code - the first attempt is usually not the best approach
\end{itemize}
\end{frame}


\begin{frame}{Literature Recommendations}
R Resources
\begin{itemize}
\item Advanced R Ed. 1 (\url{http://adv-r.had.co.nz/})
\item Advanced R Ed. 2 (\url{https://adv-r.hadley.nz/})
\item Notes on Functionals (\url{https://www.stat.umn.edu/geyer/8054/notes/functional.html})
\item R language definition (\url{https://cloud.r-project.org/doc/manuals/r-release/R-lang.html})
\item R Inferno (\url{https://www.burns-stat.com/pages/Tutor/R_inferno.pdf})
\item R Packages (\url{https://r-pkgs.org/})
\item Clean Code (\url{https://enos.itcollege.ee/~jpoial/oop/naited/Clean\%20Code.pdf})
\end{itemize}



\end{frame}


\begin{frame}[plain]

\begin{center}
\Large Thank you for your attention!

\visible<2>{Questions? Remarks?}
\end{center}

\end{frame}

\end{document}
