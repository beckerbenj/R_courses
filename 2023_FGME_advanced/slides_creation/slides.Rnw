\documentclass{beamer}

\usepackage{multicol}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{shapes.geometric}
\usepackage{hyperref}
\usepackage{url}

\usetheme{metropolis}



\title{Programming in R}
\institute{FGME Post-Conference Workshop}


\author[Dries Debeer \& Benjamin Becker]{Dries Debeer \& Benjamin Becker}
\date{14. September 2023}



<<r setup, echo=FALSE, message=FALSE, results="hide">>=
suppressPackageStartupMessages({
  library(knitr)
})

options(tinytex.verbose = TRUE)

knit_theme$set("acid")
opts_chunk$set(results="markup")
opts_chunk$set(echo = TRUE)
opts_chunk$set(eval = TRUE)
opts_chunk$set(strip.white = TRUE)
opts_chunk$set(size = "footnotesize")
opts_chunk$set(comment = ">")
opts_chunk$set(fig.width=3.5, fig.height=3) 


# Farben
mLightBrown<-"#EB811B"
econBlue<-"#008BBC"
econRed<-"#C10534"
econBlueD<-"#3E647D"
econRedD<-"#90353B"
@


\begin{document}



\begin{frame}
\titlepage
\end{frame}
\addtocounter{framenumber}{-1}


\setcounter{tocdepth}{3}

% \begin{frame}{Table of Content}
% \fontsize{5pt}{4}
% 
% \begin{multicols}{3}
%   \tableofcontents
% \end{multicols}
% \end{frame}


\section{Introduction}

\begin{frame}{Introduction}
\begin{columns}[t]
\begin{column}{.475\textwidth}
    \textbf{Who are we?} 
    
    \vspace{0.3cm}
    
    \textcolor{mLightBrown}{Dries Debeer} \\
    
    \vspace{0.2cm}
    
    Statistical Consultant at Ghent University (FPPW)
\end{column}
\begin{column}{.475\textwidth}
    \textbf{} 
    
    \vspace{0.3cm}
    
    \textcolor{mLightBrown}{Benjamin Becker} \\
    
    \vspace{0.2cm}
    
    Researcher at IQB (Verbund Forschungsdaten)
    
\end{column}
\end{columns}

\vspace{0.2cm}

\begin{columns}[t]
\begin{column}{.475\textwidth}
\href{https://github.com/ddebeer/scDIFtest}{scDIFtest}, \href{https://github.com/ddebeer/permimp}{permimp}, \href{https://github.com/beckerbenj/eatATA}{eatATA}, \href{https://CRAN.R-project.org/package=mstDIF}{mstDIF}
  	
\end{column}
\begin{column}{.475\textwidth}
\href{https://github.com/beckerbenj/eatGADS}{eatGADS}, \href{https://github.com/beckerbenj/eatDB}{eatDB}, \href{https://github.com/beckerbenj/eatATA}{eatATA}, \href{https://github.com/beckerbenj/pisaRT}{pisaRT}

  \end{column}
\end{columns}

\vspace{0.3cm}

\begin{columns}[t]
\begin{column}{.475\textwidth}

\href{mailto:dries.debeer@ugent.be}{dries.debeer@ugent.be}
  	
\end{column}
  \begin{column}{.475\textwidth}

\href{b.becker@iqb.hu-berlin.de}{b.becker@iqb.hu-berlin.de}

  \end{column}
\end{columns}

\vspace{1.5em}
\end{frame}

\begin{frame}{Introduction}
\textbf{Who are you?}
\begin{enumerate}%\itemsep0em
	\item Position and research topics?
	\item Previous knowledge and experience
	\begin{itemize}
	  \item with R?
	  \item with other statistical software?
	  \item with other programming languages?
	\end{itemize}
	\item Specific interest/motivation for this workshop?
\end{enumerate}
\end{frame}


\subsection{Motivation}

\begin{frame}{Motivation}
\textbf{Why care about R coding?}
	\begin{enumerate}
			\item Increase efficiency!
			\begin{itemize}
			  \item Save time and nerves
			  \item Avoid errors and bugs
			  \item High transfer effect to other projects (with data analysis)
			\end{itemize}
			\item Successful collaborations (including with your future self!)
			\item Code as deliverable (i.e., part of research paper)
	\end{enumerate}
\end{frame}

% \begin{frame}{Motivation}
% 	Two of your worst collaborators:
% 	\begin{enumerate}
% 			\item Past Self
% 			\begin{itemize}
% 			  \item the biggest mess in existence
% 			  \item did not document anything
% 			  \item uses a completely different style of writing code
% 			  \item does not reply to e-mails
% 			\end{itemize}
% 			\item Future Self
% 			\begin{itemize}
% 			  \item has the memory of a goldfish
% 			  \item will have zero understanding for your current brilliance
% 			\end{itemize}
% 	\end{enumerate}
% \end{frame}

%\begin{frame}{Motivation}
%\begin{center}
%\includegraphics[width=.6\textwidth]{reinhart_rogoff.PNG}
%\end{center}
%\end{frame}

\begin{frame}{Motivation}
\begin{center}
\includegraphics[width=.75\textwidth]{bad_code_media.JPG}
\end{center}
\end{frame}


\subsection{Goal}

\begin{frame}{Goal of this workshop}

\textbf{A deeper dive into R as a Programming language}
\begin{itemize}
  \item Better practical R skills
  \item Better understanding of R (and programming)
  \item Different framing: R as a programming language
\end{itemize}
\end{frame}

\subsection{Agenda}

\begin{frame}{Agenda}
\begin{itemize}
  \item Loops \& iteration
  \item Functions (part I)
  \item Functions (part II)
  \item Functionals \& split-apply-combine
  \item Good programming practices
\end{itemize}
\end{frame}


% ----------------------------------------------------------------------------------------------------------------------
\section{Quick Recap}
\label(sec:recap)

\begin{frame}{Basic \emph{Objects} in R}
\begin{center}
  \begin{tabular}{| l | l |}
    \hline
    \multicolumn{2}{|c|}{Vectors} \\ \hline
    logical   & \texttt{TRUE}, \texttt{FALSE}, \texttt{NA} \\ 
    integer   & \texttt{1L}, \texttt{142}, \texttt{-5}, ..., \texttt{NA} \\
    double    & \texttt{1.0}, \texttt{1.25784}, \texttt{pi}, ..., \texttt{NA} \\
              & \texttt{NaN}, \texttt{-Inf}, \texttt{Inf} \\
    character & \texttt{"1"}, \texttt{"Some other string"}, ..., \texttt{NA} \\
    \hline
  \end{tabular}
\end{center}
Vectors can have multiple elements \textbf{of the same type} $\rightarrow$ \texttt{length()} starting from \texttt{0}
\end{frame}


\begin{frame}[fragile]{Basic \emph{Objects} in R}
\begin{center}
  \begin{tabular}{| l | l |}
    \hline
    \multicolumn{2}{|c|}{More basic object types} \\ \hline
    list        & a list of vectors \texttt{list()}, \texttt{as.list()}, ...  \\    \hline
    matrix      & a \textbf{vector} with \texttt{"dim"} argument: two dimensions \\
                & \texttt{matrix()}, \texttt{as.matrix()} \\ 
                & matrix algebra \\ 
    array       & a \textbf{vector} with with \texttt{"dim"} argument \\            \hline
    data.frame  & a \textbf{list} with vectors of equal length  \\
                & \texttt{data.frame()}, \texttt{as.data.frame()}  \\
    \hline
  \end{tabular}
\end{center}
\end{frame}


\begin{frame}[fragile]{\texttt{data.frame} vs \texttt{matrix}}
A \texttt{data.frame} is a list of vectors $\rightarrow$ columns can be of different types.

<<data.frame, echo=TRUE, eval = TRUE, results = "markup">>=
iris_dat <- head(iris)
is.list(iris_dat)
dim(iris_dat)
length(iris_dat)
iris_dat[1:2,]
@

\end{frame}


\begin{frame}[fragile]{\texttt{data.frame} vs \texttt{matrix}}
A \texttt{matrix}/\texttt{array} is a vector with dimensions $\rightarrow$ all elements/columns are of the same type.
<<matrix, echo=TRUE, eval = TRUE, results = "markup">>=
iris_mat <- as.matrix(iris_dat)
dim(iris_mat)
length(iris_mat)
iris_mat[1:2,]
@

\end{frame}



\section{Loops \& Iteration}
\label{sec:loops}

\begin{frame}{Loops \& iteration}
R has specific tools (functions) that help organize the flow of computations. \\
You can repeat a similar computation multiple times typically with changing options (``iteration'').
The most commonly used tools are:
\begin{itemize}
  \item loops
  \begin{itemize}
    \item \texttt{for}
    \item \texttt{while}
    \item \texttt{repeat}
  \end{itemize}
  \item \texttt{apply} - family
\end{itemize}
\end{frame}


\subsection{for}

\begin{frame}[fragile]{Loops \& Iteration - for}
\texttt{for} statements have the basic form
<<for, echo=TRUE, eval = FALSE>>=
for (element in vector) {
  computation
}
@
For each element in the vector, the computation is executed. \\
Often, the computation depends on the element in that iteration.
\end{frame}

\begin{frame}[fragile]{Loops \& Iteration - for}
<<for2, echo=TRUE, eval = TRUE, results = "markup">>=
# iterate over a numeric vector
for (index in 1:3){
  cat(" computation -")
}

# iterate over a character vector
for (name in c("Alice", "Bob", "Casey")){
  if(name == "Bob") cat(" This was Bob -")
  else cat(" Not Bob -")
}
@
\end{frame}


\subsection{while \& repeat}

\begin{frame}[fragile]{Loops \& Iteration - while}
\texttt{while} statements have the basic form
<<while, echo=TRUE, eval = FALSE>>=
while (condition){
  computation
}
@
As long as the condition is TRUE, the computation is executed. \\ Often, the computation depends on something that is related to the condition.
\end{frame}

\begin{frame}[fragile]{Loops \& Iteration - repeat}
\texttt{repeat} statements have the basic form
<<repeat, echo=TRUE, eval = FALSE>>=
repeat {
  computation
}
@
Without a \texttt{break} the computation is repeated infinite times
\end{frame}

\subsection{next \& break}

\begin{frame}[fragile]{Loops \& Iteration - next break}
\begin{itemize}
  \item \texttt{next} starts next iteration
  \item \texttt{break} ends iteration (of the innermost loop)
\end{itemize}
<<next, echo=TRUE, eval = TRUE, results="markup">>=
index <- 0
repeat {
  index <- index + 1
  if (index %in% c(3, 5)) next
  if (index > 6) break
  print(index)
}
@
\end{frame}


\begin{frame}[fragile]{Loops \& Iteration - next break}
\begin{itemize}
  \item \texttt{next} starts next iteration
  \item \texttt{break} ends iteration (of the innermost loop)
\end{itemize}
Same idea, now with for loop
<<next2, echo=TRUE, eval = TRUE, results="markup">>=
for(index in 1:6) {
  if (index %in% c(3, 5)) next
  print(index)
}
@
\end{frame}


\begin{frame}[fragile]{Loops \& Iteration - nested loops}
Nested loops (over the rows and columns of a matrix)
<<for3, echo=TRUE, eval = TRUE, results = "markup">>=
matrix <- matrix(NA, nrow = 2, ncol = 3)
for (rowNr in 1:2){
  for (colNr in 1:3){
    matrix[rowNr, colNr] <- rowNr * 10 + colNr
  }
}
matrix
@
\end{frame}



\subsection{Loops \& Iteration - good practice}

\begin{frame}[fragile]{Iteration - Good practice}
\metroset{block=fill} %grey blocks
\begin{block}{Programming advice}
Use \texttt{seq()}, \texttt{seq\_len()}, or \texttt{seq\_along()}.
\end{block}
<<seq2, echo=TRUE, eval = TRUE, results="markup", size="footnotesize">>=
x <- numeric()
for (index in 1:length(x)){
  print(index)
}

for (index in seq_along(x)){
  print(index)
}
@
\end{frame}

\begin{frame}[fragile]{Loops \& Iteration - Good practice}
\metroset{block=fill} %grey blocks
\begin{block}{Programming advice}
Don't grow, replace.
\end{block}
<<replace, echo=TRUE, eval = TRUE, results="markup">>=
x <- letters
result1 <- numeric()          # grow
result2 <- numeric(length(x)) # replace
for (index in seq_along(x)){
  result1 <- c(result1, paste(index, x[index]))  # grow
  result2[index] <- paste(index, x[index])       # replace
}
@
\end{frame}

\subsection{apply}

\begin{frame}[fragile]{Loops \& Iteration - apply}
\texttt{apply} lets you iterate over rows or columns of a matrix or data.frame. You can \emph{apply} a function to all rows/columns
<<applyDef, echo=TRUE, results="markup", size="footnotesize", eval = FALSE>>=
apply(matrix,
     MARGIN = 1,       # 1 = iterate over rows
                       # 2 = iterate over columns
     FUN = function)   # function to apply to rows/columns
@
\end{frame}


\subsubsection{apply}

\begin{frame}[fragile]{apply}
\begin{itemize}
  \item for objects with dimensions (matrix, array, data.frame)
  \item apply over (a) chosen dimension(s) 
\end{itemize}
<<apply, echo=TRUE, results="markup", size="footnotesize">>=
my_matrix <- matrix(1:6, nrow = 2)
apply(my_matrix, 1, max)    # apply per row
apply(my_matrix, 2, max)    # apply per column
@
\end{frame}

\begin{frame}[fragile]{apply}
<<apply2, echo=TRUE, results="markup", size="footnotesize">>=
my_array <- array(1, dim = c(2, 3, 4))
apply(my_array, c(1, 2), sum)  # per row and column
apply(my_array, 3, sum)        # per "third dimension"
@
\end{frame}


\begin{frame}[plain]
\begin{center}
\Large Exercises \\

\vspace{1.5cm}
\includegraphics[height=.25\textheight]{exercises.jpg}
\end{center}
\end{frame}

% ----------------------------------------------------------------------------------------------------------------------
\section{Functions I}
\label{sec:fun1}

\begin{frame}[fragile]
\begin{exampleblock}{}
  {\large \begin{quote}
``To understand computations in R, two slogans are helpful: Everything that exists is an object. {Everything} that happens is a function call.''
\end{quote}}
  \vskip5mm
  \hspace*\fill{\small--- John Chambers, Extending R (2016)}
\end{exampleblock}
\end{frame}


\subsection{Function Calls}

\begin{frame}{Function Calls}
Computing in R happens through function calls. A function is applied to one or more objects, and returns an object after the computation. 

\begin{figure}
\begin{center}
\begin{tikzpicture}
\node[draw,ellipse] (s1) at (0,0) {function};
\node[draw,rectangle] (s2) at (-4,0) {object1, \ (object2, ...)};
\node[draw,rectangle] (s3) at (3,0) {new object};
\path
    (s2) edge[->, double distance=1pt, >=latex'] (s1)
    (s1) edge[->, double distance=1pt, >=latex'] (s3);
\end{tikzpicture}
\end{center}
\caption{A function call.}
\label{fig1}
\end{figure}

The typical use is: \\ 
  \texttt{function(object1, argument = object2)}
  
\end{frame}

\begin{frame}{Function Calls}
\begin{itemize}
  \item Computations that seem not to be done using function calls are actually also function calls. \ 
  Try \texttt{\textasciigrave <-\textasciigrave (a, 5)} or \texttt{\textasciigrave >\textasciigrave (5, 2)}
  \item most functions that seem not to return an object, return it invisibly. Check \texttt{(a <- 5)}.
\end{itemize}
\end{frame}

\begin{frame}{Building Blocks}
Functions are the building blocks of R code. Writing functions allows you to organize and optimize the computations that you want to do. \\
Functions should:
\begin{itemize}
  \item have a clear purpose
  \item be well documented
  \item be portable
\end{itemize}
\end{frame}

\begin{frame}{Stepping Stone}
\textbf{Central stepping stone for R users:} \\
Move from solely using functions written by others to writing your own functions. 
\end{frame}


\begin{frame}{Function definition}
\begin{itemize}
  \item Name
  \item Arguments/Formals (input)
  \item Body (what happens inside, R-code with the computations)
  \item Output 
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Function definition}
<<echo=TRUE, size = "footnotesize">>=
                            # Name
countNA <- function(x) {    # Arguments/Formals
  out <- sum(is.na(x))      # Body
  out                       # Output
}
@
\end{frame}

\subsection{Function Names}

\begin{frame}{Function Names}
Every function needs a (meaningful) name!
\begin{itemize}
  \item Usually \textbf{a verb} (what does the function do?)
  \item Avoid existing names 
  \item Better longer than unclear
  \item CamelCase vs snake\_case
\end{itemize}
\end{frame}

\begin{frame}{Function Names}
\textbf{Good}
\begin{itemize}
  \item \texttt{computeAIC()}
  \item \texttt{removeNAs()}
  \item \texttt{drop\_NA\_rows()}
  \item \texttt{factor\_to\_dummies()}
\end{itemize}
\textbf{Bad}
\begin{itemize}
  \item \texttt{myFun()}
  \item \texttt{foo()}
  \item \texttt{statistics()}
  \item \texttt{data\_preparation()}
\end{itemize}
\end{frame}

\subsection{Arguments}

\begin{frame}{Arguments}
Most functions take one or multiple inputs. \\
These are usually:
\begin{itemize}
  \item One or two data arguments
  \item Additional Options
\end{itemize}
\end{frame}

\begin{frame}{Arguments}
Functions with zero arguments
\begin{itemize}
  \item \texttt{getwd()}
  \item \texttt{Sys.time()}
  \item ...
\end{itemize}
\end{frame}

\begin{frame}{Arguments}
Functions with one argument
\begin{itemize}
  \item \texttt{dim()}
  \item \texttt{names()}
  \item ...
\end{itemize}
\end{frame}

\begin{frame}{Arguments}
Functions with  multiple arguments
\begin{itemize}
  \item \texttt{mean()}
  \item \texttt{median()}
  \item \texttt{lm()}
  \item ...
\end{itemize}
\end{frame}

\begin{frame}{Arguments}
\metroset{block=fill} %grey blocks
\begin{block}{Programming advice}
Less arguments = better!
\end{block}
\end{frame}

\begin{frame}[fragile]{Arguments}
Often arguments have to be objects of a specific type.
<<echo=TRUE, eval = TRUE, error = TRUE >>=
sum(c("a", "b", "c"))  # gives an error
@
The documentation typically gives (or should give) information about what 
objects the arguments should be. Check \texttt{?sum}
\end{frame}



\subsection{Default Arguments}

\begin{frame}[fragile]{Default arguments}
What happens if the user omits an argument?
<<echo=TRUE, size = "footnotesize">>=
countNA <- function(x, percent) {
  out <- sum(is.na(x))
  if(percent) out/length(x)
  out                   
}
x <- c(1, 5, NA, 3)
countNA(x = x)
@
\end{frame}

\begin{frame}[fragile]{Default arguments}
Default arguments are made for such instances!
<<echo=TRUE, eval=TRUE>>=
countNA <- function(x, percent = FALSE) {
  out <- sum(is.na(x))
  if(percent) out/length(x)
  out                   
}
x <- c(1, 5, NA, 3)
countNA(x = x)
@
\end{frame}

\begin{frame}[fragile]{Default arguments}
Additional arguments give (the user) flexibility. Default arguments keep the function easy to use. 

\vspace{0.3cm}

Try \texttt{?lm}
\metroset{block=fill} %grey blocks
\begin{block}{Programming advice}
\begin{itemize}
  \item Think about which arguments to include, and which should (not) have defaults
  \item Choose sensible defaults
\end{itemize}
\end{block}
\end{frame}

\subsection{Return object}

\begin{frame}{Single return object}
Pure functions return a single object.
\begin{itemize}
  \item (Standard) The last evaluated object 
  \item Object defined by return()
\end{itemize}

\begin{figure}
\begin{center}
\begin{tikzpicture}
\node[draw,ellipse] (s1) at (0,0) {function};
\node[draw,rectangle] (s2) at (-4,0) {object1, \ (object2, ...)};
\node[draw,rectangle] (s3) at (3,0) {new object};
\path
    (s2) edge[->, double distance=1pt, >=latex'] (s1)
    (s1) edge[->, double distance=1pt, >=latex'] (s3);
\end{tikzpicture}
\end{center}
\caption{A pure function.}
\label{pure_function}
\end{figure}
\end{frame}

\begin{frame}[fragile]{Return object}
\texttt{return()} stops the computation, and returns the object.
<<echo=TRUE>>=
return_early <- function(x, early) {
  x2 <- x*2
  if(early) (return(x2))
  out <- x + x2 # not executed
  out
}
return_early(2, early = TRUE)
return_early(2, early = FALSE)
@
\end{frame}


\begin{frame}[fragile]{Return object}
Multiple return objects can be combined in a list!
<< eval = FALSE, size = "footnotesize">>=
                                            # Name
do_this <- function(vector, other_vector) { # Arguments
  # many computations                       # Body
  return(list(output1 = this, 
              output2 = that))              # Output
}
@
\end{frame}

\begin{frame}[fragile]{Return Object}
The return object as a list with multiple objects.
<< eval = TRUE, size = "footnotesize">>=
get_info <- function(x){
  mean_x <- mean(x)
  median_x <- median(x)
  n_obs_x <- length(x)
  range_x <- range(x)
  return(list(mean = mean_x, median = median_x, 
              n_obs = n_obs_x, range = range_x))
}
str(get_info(airquality$Wind))
@
\end{frame}


\subsection{Debugging}

\begin{frame}{Debugging}
\begin{itemize}
  \item browser()
  \item traceback()
  \item options(error = recover)
  \item options(warn = 2)
\end{itemize}
\end{frame}

\begin{frame}[fragile]{browser()}
Inspecting a function interactively
<< eval=FALSE>>=
some_function <- function(x, y) {
  z <- x + y
  browser()
  z
}
some_function(x = 1, y = 5)
@
\end{frame}

\begin{frame}{browser()}
\begin{center}
\includegraphics[width=.75\textwidth]{browser.JPG}
\end{center}
\end{frame}

\begin{frame}{browser()}
Navigating within a browser:
\begin{itemize}
  \item [ls()] Show existing objects in the current environment
  \item [c] Exit the browser and continue execution
  \item [Q] Exit the browser, return to top level
  \item [where] Show call stack
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Recover}
Being able to chose an environment from the call stack:
<< eval=FALSE>>=
# on
options(error = recover)

# off
options(error = NULL)
@
\end{frame}

\begin{frame}{Recover}
Being able to chosse an enrivonment from a call stack:
\begin{center}
\includegraphics[width=.75\textwidth]{recover.JPG}
\end{center}
\end{frame}

\begin{frame}[fragile]{Warnings}
Turning warnings into errors
<< eval=FALSE>>=
# on
options(warn = 2)

# off
options(warn = 1)
@
\end{frame}

\begin{frame}[plain]
\begin{center}
\Large Exercises \\

\vspace{1.5cm}
\includegraphics[height=.25\textheight]{exercises.jpg}
\end{center}
\end{frame}


% ----------------------------------------------------------------------------------------------------------------------

\section{Functions II}
\label{sec:fun2}

\subsection{Why write functions?}

\begin{frame}{Reasons}
\textbf{Why write functions? }
\begin{itemize}
  \item They make code ...
  \begin{itemize}
    \item shorter (less repetition)
    \item easier to read and understand
  \end{itemize}
  \item They help avoid copy-paste errors
  \item They make it easier to change your code
  \item They increase transfer
  \begin{itemize}
    \item other use cases
    \item other projects
    \item other persons
  \end{itemize}
  \item They keep your work space clean
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Readability}
\textbf{Writing a function:}
<<eval=FALSE>>=
RMSE <- get_RMSE(predictions, observations)
@
\textbf{Not writing a function:}
<<eval=FALSE>>=
diff <- observations - predictions
sq_diff <- diff^2
m_sq_diff <- mean(dif)
RMSE <- sqrt(m_sq_diff)
@
\end{frame}


\subsection{Side effects}

\begin{frame}[fragile]{Side Effects}
Functions can have \textbf{``side effects''}:
\begin{itemize}
  \item console output
  \item plots
  \item write/save on drive
  \item ...
\end{itemize}

\begin{figure}
\begin{center}
\begin{tikzpicture}
\node[draw,ellipse] (s1) at (0,0) {function};
\node[draw,rectangle] (s2) at (-4,0) {object1, \ (object2, ...)};
\node[draw,rectangle] (s3) at (3,0) {new object};
\node[draw,diamond, aspect = 2] (s4) at (3,-2) {side effect};
\path
    (s2) edge[->, double distance=1pt, >=latex'] (s1)
    (s1) edge[->, double distance=1pt, >=latex'] (s3)
    (s1) edge[->, double distance=1pt, >=latex'] (s4);
\end{tikzpicture}
\end{center}
\caption{A function with side effect.}
\label{with_side_effect}
\end{figure}
\end{frame}

\begin{frame}[fragile]{Side Effects}
Console output: \texttt{?cat} and \texttt{?print}
<< results='markup', message=TRUE, size = "footnotesize">>=
print_info <- function(x){
  info <- get_info(x)
  cat("There are ", info$n_obs, 
      " observed values. \nThe mean is ", 
      round(info$mean, 2), ". \nThe median is ", 
      round(info$median, 2), ". \n", sep = "")
}
print_info(airquality$Wind)
@
\end{frame}



\begin{frame}{Output}
\metroset{block=fill} %grey blocks
\begin{block}{Programming advice}
\begin{itemize}
  \item Write pure functions (no-side effects)
  \item Write separate functions for side effects 
  \item Plotting functions should return \texttt{NULL} or the plot as an object
\end{itemize}
\end{block}

\begin{figure}
\begin{center}
\begin{tikzpicture}
\node[draw,ellipse] (s1) at (0,0) {function};
\node[draw,rectangle] (s2) at (-4,0) {object1, \ (object2, ...)};
\node[draw,rectangle] (s3) at (3,0) {NULL};
\node[draw,diamond, aspect = 2] (s4) at (3,-2) {side effect};
\path
    (s2) edge[->, double distance=1pt, >=latex'] (s1)
    (s1) edge[->, double distance=1pt, >=latex'] (s3)
    (s1) edge[->, double distance=1pt, >=latex'] (s4);
\end{tikzpicture}
\end{center}
\caption{A side effect function.}
\label{Pure_side_effect}
\end{figure}

\end{frame}

\subsection{Error, warning, \& message}

\begin{frame}[fragile]{Error, warning, \& message}
Error: computation is interrupted without return object! 

\vspace{0.3cm}


\texttt{?stop}
<<eval = TRUE>>=
get_log_xtox <- function(x) {
  if(!is.numeric(x)) stop("This does not work!")
  x_x <- x^x
  return(log(x_x))
}
get_log_xtox("a")
@
\end{frame}

\begin{frame}[fragile]{Error, warning, \& message}
Error: computation is interrupted without return object!
\begin{figure}
\begin{center}
\begin{tikzpicture}
\node[draw,ellipse] (s1) at (0,0) {function};
\node[draw,rectangle] (s2) at (-4,0) {object1, \ (object2, ...)};
\node[draw,star, star points=10] (s4) at (3,-2) {ERROR};
\path
    (s2) edge[->, double distance=1pt, >=latex'] (s1)
    (s1) edge[->, double distance=1pt, >=latex'] (s4);
\end{tikzpicture}
\end{center}
\caption{Computation with Error.}
\label{with_error}
\end{figure}
\end{frame}


\begin{frame}[fragile]{Error, warning, \& message}
\texttt{?stopifnot} is an abbreviation for \texttt{if(!test) stop()}:
<< error = TRUE>>=
get_log_xtox <- function(x) {
  stopifnot(is.numeric(x)) 
  x_x <- x^x
  return(log(x_x))
}
get_log_xtox("a")
@
\end{frame}

\begin{frame}[fragile]{Error, warning, \& message}
Message: To inform the user about something. 

\vspace{0.3cm}

\texttt{?message} 
<<results='markup'>>=
get_log_xtox <- function(x) {
  x_x <- x^x
  message("Thank you for using this function!")
  return(log(x_x))
}
get_log_xtox(2)
@

\end{frame}

\begin{frame}[fragile]{Error, warning, \& message}
Warning: Warn the user that something may be fishy. 

\vspace{0.3cm}

\texttt{?warning}
<<>>=
get_log_xtox <- function(x) {
  if(x < 0 && (x %% 2 == 0)) 
    warning("Not sure you can trust the result.", 
            call. = FALSE)
  x_x <- x^x
  return(log(x_x))
}
get_log_xtox(-2)
@

\end{frame}

\begin{frame}[fragile]{Error, warning, \& message}
Message \& warning: computation is NOT interrupted!
\begin{figure}
\begin{center}
\begin{tikzpicture}
\node[draw,ellipse] (s1) at (0,0) {function};
\node[draw,rectangle] (s2) at (-4,0) {object1, \ (object2, ...)};
\node[draw,rectangle] (s3) at (3,0) {new object};
\node[draw,star, star points=10] (s4) at (3,-2) {\textcolor{white}{T E S T}};
\node[] (s5) at (3,-1.7) {Message,};
\node[] (s6) at (3,-2.3) {Warning};
\path
    (s2) edge[->, double distance=1pt, >=latex'] (s1)
    (s1) edge[->, double distance=1pt, >=latex'] (s3)
    (s1) edge[->, double distance=1pt, >=latex'] (s4);
\end{tikzpicture}
\end{center}
\caption{A message or warning.}
\label{with_warning}
\end{figure}
\end{frame}




\begin{frame}{Output}
\metroset{block=fill} %grey blocks
\begin{block}{Programming advice}
\begin{itemize}
  \item Choose carefully when something warrants a message, warning or error
  \item Write clear and helpful warnings, errors, messages
\end{itemize}
\end{block}
\end{frame}


\subsection{Scoping rules}


\begin{frame}[fragile]{Where does a function find objects?}
R uses specific rules to find objects, which lead to the following: 
<< results='markup'>>=
a <- 55
add_a <- function(x){
  return(x + a)
}
add_a(5)
@
When a function is called, the computations in the body are run line by line. When \texttt{R} cannot find an object inside the function, it looks outside the function.
\end{frame}



\begin{frame}[fragile]{Where does a function find objects?}
\textbf{Name masking! }

\vspace{0.3cm}

Objects inside the function mask objects outside the function with the same name.

<< results='markup'>>=
a <- 55
add_a <- function(x){
  a <- 5
  return(x + a)
}
add_a(5)
@

\end{frame}




\subsection{dot dot dot}

\begin{frame}{\texttt{...} dot-dot-dot }
R has a special argument (in the definition of the function):

\vspace{0.3cm}

\texttt{...} (dot-dot-dot)

Useful when you don't know how many arguments there will be.
\textbf{Examples:}
  \begin{itemize}
    \item \texttt{?sum}
    \item \texttt{?save}
    \item \texttt{?cbind}
    \item \texttt{?paste}
    \item ...
  \end{itemize}
\end{frame}


\begin{frame}[fragile]{\texttt{...} dot-dot-dot}
A function that checks for multiple objects if they are character vectors. (A wrapper around \texttt(?is.character))
<< results='markup', eval = TRUE>>=
is_character <- function(...){
  input <- list(...)
  out <- logical(length(input))
  for(ell_nr in seq_along(input)){
    out[ell_nr] <- is.character(input[[ell_nr]])
  }
  names(out) <- names(input)
  out
}
is_character(a = "Awesome", b = 5, new = "YES")
@
\end{frame}

\begin{frame}{\texttt{...} dot-dot-dot }
\texttt{...} can take \emph{any} number of additional arguments. \\
Useful for passing arguments to other functions like:
  \begin{itemize}
    \item \texttt{apply}-family
    \item \texttt{plot}-family
    \item ...
  \end{itemize}
\end{frame}


\begin{frame}[fragile]{\texttt{...} dot-dot-dot }
\texttt{apply} example:
<< results='markup'>>=
get_quantiles <- function(x, ...){
  if(is.null(dim(x))) return(quantile(x, ...))
  apply(x, 2, quantile, ...)
}
get_quantiles(airquality, na.rm = TRUE, 
              probs = c(.2, .8))
@
\end{frame}


\begin{frame}[fragile]{\texttt{...} dot-dot-dot}
\textbf{WARNING!} \\
Watch out with spelling mistakes, arguments can get lost!
<< results='markup'>>=
get_quantiles <- function(x, ...){
  if(is.null(dim(x))) return(quantile(x, ...))
  apply(x, 2, quantile, ...)
}
get_quantiles(airquality, na.rm = TRUE, 
              prosb = c(.2, .8))
@
\end{frame}


\subsection{Work flow}

\begin{frame}{Writing Functions}
  Before creating a function
  \begin{itemize}
    \item What should my function do?
    \item Which input objects (Arguments)?
    \item which additional options (Arguments)?
    \item What should the output object be?
  \end{itemize}
  After creating a function
  \begin{itemize}
    \item Test it
    \item Add input validation
    \item Document
  \end{itemize}
\end{frame}


\begin{frame}[plain]
\begin{center}
\Large Exercises \\

\vspace{1.5cm}
\includegraphics[height=.25\textheight]{exercises.jpg}
\end{center}
\end{frame}


% ----------------------------------------------------------------------------------------------------------------------
\section{Functionals}

\begin{frame}{Higher Order Functions}
Higher order functions are functions that either \textbf{take functions as input} or \textbf{return functions as output}.
\end{frame}


\begin{frame}{Functionals}
As defined by Hadley Wickham: A \textbf{functional} is a function that takes another function as an input. 
Common argument names are \texttt{FUN} or \texttt{f}. \\~\

\textbf{Examples}
\begin{itemize}
  \item \texttt{apply}-family
  \item \texttt{Reduce}, \texttt{Filter}
  \item \texttt{nlm}
  \item \texttt{optimize}
  \item ...
\end{itemize}
\end{frame}


\subsection{apply-family}

\begin{frame}{\texttt{apply}-family}
The \texttt{apply}-family \emph{applies} a function repeatedly. 
This can be seen as an abstraction of a for loop, with the following advantages:
\begin{itemize}
  \item requires less code to write
  \item can be easier to read / understand
  \item does not store intermediate results
  \item no need to replace / grow
\end{itemize}
\end{frame}


\begin{frame}{\texttt{apply}-family}
The members of the \texttt{apply}-family in Base R are:
\begin{itemize}
  \item \texttt{lapply} vector / list $\rightarrow$ list
  \item \texttt{sapply} vector / list $\rightarrow$ vector (matrix)
  \item \texttt{apply} matrix / array / data.frame $\rightarrow$ vector (matrix)
  \item \texttt{tapply}, \texttt{by}
  \item \texttt{mapply}, \texttt{Map}
  \item \texttt{rapply}, \texttt{eapply}, \texttt{vapply} 
\end{itemize}
\end{frame}

\begin{frame}{\texttt{apply}-family}
A popular alternative from the tidyverse: \href{https://purrr.tidyverse.org/}{\texttt{purrr-package}} 
\begin{itemize}
  \item \texttt{map} vector / list $\rightarrow$ list
  \item \texttt{map2} multiple vectors / lists $\rightarrow$ list
  \item ...
\end{itemize}
\end{frame}

\subsection{lapply}

\begin{frame}{lapply}
Our focus: \texttt{lapply}

\textbf{Why?}
\begin{itemize}
  \item Consistent output
  \item Fast
  \item No dependencies
  \item We want to understand R basics
\end{itemize}
\end{frame}


\subsubsection{lapply}

\begin{frame}[fragile]{lapply}
\texttt{lapply} has two main arguments
\begin{itemize}
  \item[\texttt{X}] the input list/vector
  \item[\texttt{FUN}] the function that should be repeatedly applied
\end{itemize}
<<lapply1, echo=TRUE, results="markup", size="footnotesize">>=
example_list <- list(vec1 = c(1, 3, 4),
                     vec2 = c(4, 2, 10), 
                     vec3 = c(2, NA, 1))
lapply(example_list, FUN = mean)
@
\end{frame}

\begin{frame}[fragile]{lapply}
Other arguments can be passed through \texttt{lapply} via '\texttt{...}'.
<<lapply2b, echo=TRUE, results="markup", size="footnotesize">>=
example_list <- list(vec1 = c(1, 3, 4),
                     vec2 = c(4, 2, 10), 
                     vec3 = c(2, NA, 1))
lapply(example_list, FUN = mean, na.rm = TRUE) 
@
\end{frame}

\begin{frame}[fragile]{lapply}
We can use our own functions as input.
<<lapply3, echo=TRUE, results="markup", size="footnotesize">>=
dropNAs <- function(x) {
  x[!is.na(x)]
}
lapply(example_list, FUN = dropNAs) 
@
\end{frame}

\begin{frame}[fragile]{lapply}
Anonymous functions can be used as input.
<<lapply4, echo=TRUE, results="markup", size="footnotesize">>=
lapply(example_list, FUN = function(x) x[!is.na(x)]) 
@
\end{frame}

\begin{frame}[fragile]{lapply}
Data.frames are lists, too.
<<lapply5, echo=TRUE, results="markup", size="footnotesize">>=
lapply(iris, FUN = class)
@
\end{frame}

\begin{frame}[fragile]{lapply}
Atomic vectors can be used as input, but often vectorization could be used instead.
<<lapply6, echo=TRUE, results="markup", size="footnotesize">>=
lapply(c(1, 2, 3), FUN = function(x) {
  paste0("ID", x)
})
@
\end{frame}

\begin{frame}[fragile]{lapply}
Limitation of \texttt{lapply}:\\
Only a single list/vector can be supplied as input. \texttt{Map} is a generalization of \texttt{lapply}!
It is usually needed less often but a very powerful tool.
\end{frame}


\subsection{Split \& Apply \& Combine}

\begin{frame}[fragile]{Split \& Apply \& Combine}
A common use case for the \texttt{apply-}family is the \textbf{Split \& Apply \& Combine} paradigm.
Here, we want to perform the same analyses for various subgroups in our data set:

\begin{itemize}
  \item \textbf{split} a data.frame or vector (\texttt{?split})
  \item \textbf{apply} computations on each split (\texttt{?lapply})
  \item \textbf{combine} the results (\texttt{?do.call})
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Split \& Apply \& Combine}
\begin{center}
\includegraphics[width=.75\textwidth]{split-apply-combine.png}
\end{center}
\end{frame}

\begin{frame}[fragile]{Split \& Apply \& Combine}

<<SAC1, echo=TRUE, eval = TRUE, results='markup'>>=
head(iris)
table(iris$Species)
@
\end{frame}

\begin{frame}[fragile]{Split \& Apply \& Combine}
Splitting the data set via a single (or multiple) grouping variables

<<SAC2, echo=TRUE, eval = TRUE, results='markup'>>=
data_list <- split(iris, f = iris$Species)
class(data_list)
length(data_list)
@
\end{frame}

\begin{frame}[fragile]{Split \& Apply \& Combine}
Apply the same computation to all data sets

<<SAC3, echo=TRUE, eval = TRUE, results='markup'>>=
out_list <- lapply(data_list, function(subdat) {
  mod <- lm(Sepal.Length ~ Sepal.Width, data = subdat)
  sum_mod <- summary(mod)
  out <- c(Intercept = coef(mod)[[1]], 
    Slope = coef(mod)[[2]],
    r2 = sum_mod$r.squared)
  round(out, 3)
})
@
\end{frame}

\begin{frame}[fragile]{Split \& Apply \& Combine}
<<SAC4, echo=TRUE, eval = TRUE, results='markup'>>=
out_list[["virginica"]]
@
\end{frame}

\begin{frame}[fragile]{Split \& Apply \& Combine}
Combine the results
<<SAC5, echo=TRUE, eval = TRUE, results='markup'>>=
do.call(rbind, out_list)
@
\end{frame}


\begin{frame}[plain]
\begin{center}
\Large Exercises \\

\vspace{1.5cm}

\includegraphics[height=.25\textheight]{exercises.jpg}
\end{center}
\end{frame}



% ----------------------------------------------------------------------------------------------------------------------
\section{Good programming practices}
\label{sec:good}

\subsection{Code Style}

\begin{frame}[fragile]
\begin{exampleblock}{}
  {\large ``Write code for humans, not for machines!''}
  \vskip5mm
  \hspace*\fill{\small}
\end{exampleblock}
\end{frame}

\begin{frame}{Code Style}
Invest time in writing readable R-code.
\begin{itemize}
  \item It will make collaborations easier
  \item It will make debugging easier
  \item It will make your analyses more reproducible 
\end{itemize}
There is a complete \emph{tidyverse} style-guide \url{https://style.tidyverse.org/}.
\end{frame}

\subsection{Go easy on your eyes}

\begin{frame}{Go easy on your eyes}
\begin{itemize}
  \item with spaces before and after: \texttt{-  +  /  *  =  <-  <  ==  > }
  \item always use \texttt{<-} for assignments
  \item only use \texttt{=} in function calls
  \item use indentation (largely automatic in RStudio)
  \item \texttt{CamelCaseNames} vs \texttt{snake\_case\_names}
  \item be consistent!
  \item wrap long lines at column 70-80 (Rstudio)
\end{itemize}
\end{frame}

\begin{frame}[fragile]{White space}
<<White space, eval = FALSE>>=
new_var=(var1*var2/2)-5/(var3+var4)

# versus

new_var <- (var1 * var2 / 2) - 5 / (var3 + var4)
@
\end{frame}

\begin{frame}[fragile]{Indentation}
<<Indentation, eval = FALSE, size="footnotesize">>=
for(name in names){formula=as.formula(paste0("y~.-",name))
fit<-lm(formula,data=my_data)
coefs[["name"]]=coef(fit)
print(name)
print(summary(fit))}

# versus

for(name in names){
  formula <- as.formula(paste0("y~.-", name))
  fit <- lm(formula, data = my_data)
  coefs[["name"]] <- coef(fit)
  print(name)
  print(summary(fit))
}
@
\end{frame}

\begin{frame}[fragile]{Wrap long lines}
<<Wrap long lines, eval = FALSE , size="footnotesize">>=
final_results <- data.frame(first_variable = 
sqrt(results$mean_squared_error), second_variable = 
paste0(results$condition, results$class, sep = ":"), 
third_variable = results$bias)

# versus

final_results <- data.frame(
  first_variable = sqrt(results$mean_squared_error), 
  second_variable = paste0(results$condition, 
                           results$class, sep = ":"),
  third_variable = results$bias)
@
\end{frame}

\subsection{Go easy on your mind}

\begin{frame}{Go easy on your mind}
\begin{itemize}
  \item use meaningful names: ``self-explainable''
  \item always write the formal arguments in function calls (except the first)
  \item benefit from autocompletion (\texttt{<tab>}) => embrace longer names
  \item use \texttt{TRUE} and \texttt{FALSE} not \texttt{T} and \texttt{F}
  \item comment, comment, comment
  \begin{itemize}
    \item NOT what (should be clear from the code)
    \item but why
    \item explain the reasoning, not the code 
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Use meaningful names}
<<Use meaningful names, eval = FALSE >>=
V <- myFun(m1_B)

# versus

RMSE_age_gender <- get_RMSE(lm_age_gender)
@
\metroset{block=fill} %grey blocks
\begin{block}{Programming advice}
Use \texttt{verbs} for functions and \texttt{nouns} for other objects.
\end{block}
\end{frame}

\begin{frame}[fragile]{Write formal arguments}
Benefit from auto completion using \texttt{tab}
<<Write formal arguments, eval = FALSE , size="footnotesize">>=
m1_B <- lm(outcome ~ age*gender, 
           exp1, condition_1, freq)

# versus

lm_age_gender <- lm(outcome ~ age * gender, 
                    data = exp1, 
                    subset = condition_1, 
                    weigths = freq)
@
\end{frame}

\begin{frame}[fragile]{Comment, comment, comment}
<<Comment, eval = FALSE , size="footnotesize">>=
## Start every Rscript with a comment that explains 
##  what the code in the script does, why it does 
##  this, and to which project it belongs. 
##  Your future self will be very thankful!
##
## Mention which packages you are using in this Rscript.

## Use sections to separate chunks ----------------------

## Maybe even subsections ===============================

## Recode variables so that missings are coded as "NA"
dat[dat %in% c(99, 999)] <- NA  # missings coded 99 or 999
@
\end{frame}


\subsection{R Peculiarities}


\begin{frame}[fragile]{Keep your code slim}
Try to limit your \emph{package-dependencies}.

\vspace{0.3cm}

Only load \texttt{library()} the packages that you absolutely need. If you are only using \texttt{dplyr}, it does not make sense to load the complete \texttt{tidyverse}.

\vspace{0.3cm}

\textbf{Controversial:} when possible, use the \texttt{::} operator (and consider not loading the package). \texttt{<package>::<function>} 
\begin{itemize}
  \item explicit dependencies
  \item less name conflicts
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Never Attach}
Forget about \texttt{attach()}! 

\vspace{0.3cm}

Don't use it, unless you completely understand what happens (see \texttt{?attach}).

\vspace{0.3cm}

Use \texttt{with(data.frame, expression)} instead.
<<attach, eval = FALSE >>=
# using with()
n <- 2e+4
data <- data.frame(x = runif(n), 
                   y = runif(n), 
                   z = seq_len(n))
result <- with(data, exp(x) / log(z) + 5 * sqrt(y))
@
\end{frame}


\begin{frame}{Testing R code}
Writing code is error prone. Incorporate tests and checks in your workflow. 
\begin{itemize}
  \item minimal examples
  \item write tests and checks
  \item helpful packages: \texttt{testthat}, \texttt{RUnit}, \texttt{testit}, ...
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Speed}
Computing speed can become an issue. Avoid common pitfalls:
\begin{itemize}
  \item don't grow, but replace
  \item vectorize where possible
  \item check the computing speed
\end{itemize}
\texttt{?system.time},  \text{microbenchmark} or profiling tools
<< >>=
n <- 2e+4
data <- data.frame(x = runif(n), 
                   y = runif(n), 
                   z = seq_len(n))
@
\end{frame}


\begin{frame}[fragile]{Speed}
Don't grow!
<< >>=
system.time({
  new_data <- NULL
  
  for(row_nr in seq_len(NROW(data))){
    new_data <- cbind(
      data[row_nr,], 
      result = exp(data$x[row_nr]) /
        log(data$z[row_nr]) + 
        5 * sqrt(data$y[row_nr]))
  }  
})
@
\end{frame}


\begin{frame}[fragile]{Speed}
Replace!
<< >>=
system.time({
  n_rows <- dim(data)[1]
  data$result <- rep(NA, n_rows)
  
  for(row_nr in seq_len(n_rows)){
    data$result[row_nr] <- exp(data$x[row_nr]) / 
      log(data$z[row_nr]) + 
      5 * sqrt(data$y[row_nr])
  } 
})
@
\end{frame}


\begin{frame}[fragile]{Speed}
Vectorize!
<< >>=
system.time({
  data$result <- exp(data$x) / log(data$z) + 
    5 * sqrt(data$y)
})
@
\end{frame}



\begin{frame}[fragile]{Speed}
Compare the speed of different implementations using: 

\vspace{0.3cm}

\texttt{microbenchmark::microbenchmark}
<< >>=
get_mean1 <- function(x){
  weight <- 1/length(x)
  out <- 0
  for(i in seq_along(x)){
    out <- out + x[i] * weight 
  }
  return(out)
}

get_mean2 <- function(x){
  sum(x)/length(x)
}
@
\end{frame}


\begin{frame}[fragile]{Speed}
Compare the speed of different implementations using: 

\vspace{0.3cm}

\texttt{microbenchmark::microbenchmark}
<< >>=
x <- rnorm(500)
microbenchmark::microbenchmark(
  mean(x), get_mean1(x), get_mean2(x))
@
\end{frame}


\begin{frame}[fragile]{Speed}

\metroset{block=fill} %grey blocks
\begin{block}{Programming advice}
Don't worry about speed before it becomes an issue.
\end{block}
\end{frame}





% ----------------------------------------------------------------------------------------------------------------------
\section{Wrap Up}

\begin{frame}{General Advice}
\begin{itemize}
\item Investing time in learning R pays off
\item It's a steady learning curve
\item Learn from masters
\item Rewrite important code - the first attempt is usually not the best approach
\end{itemize}
\end{frame}

\begin{frame}{General R Advice}
\begin{itemize}
\item Document well
\item Use a consistent style
\item Write functions
\item Split long functions in smaller ones
\item Write wrappers
\item Use Iteration (don't copy paste)
\item Use matrix operations and vectorized functions instead of loops
\item Use git
\end{itemize}
\end{frame}

\begin{frame}{Literature Recommendations}
R Resources
\begin{itemize}
\item Avanced R Ed. 1 (\url{http://adv-r.had.co.nz/})
\item Avanced R Ed. 2 (\url{https://adv-r.hadley.nz/})
\item R Inferno (\url{https://www.burns-stat.com/pages/Tutor/R_inferno.pdf})
\item R Packages (\url{https://r-pkgs.org/})
\item Clean Code (\url{https://mooc.aptikom.or.id/pluginfile.php/1174/mod_resource/content/1/Clean\%20Code_\%20A\%20Handbook\%20of\%20Agile\%20Software\%20C\%20-\%20Robert\%20C.\%20Martin.pdf})
\end{itemize}

\end{frame}


\begin{frame}[plain]

\begin{center}
\Large Thank you for your attention!

\visible<2>{Questions? Remarks?}
\end{center}

\end{frame}

\end{document}
